<html>
<head>


<meta http-equiv="cache-control" content="max-age=0" />
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="expires" content="0" />
<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
<meta http-equiv="pragma" content="no-cache" />


<meta charset="UTF-8">
<style type="text/css">
table, th, td {
   border-width: 1px;
   border-style: solid;
   border-collapse: collapse;
   text-align:center;
   padding: 1px 5px 1px 5px;
}
th {
   background-color: lightyellow;
}
th.thh {
   background-color: lightcyan;
}
th.ths, th.thsa {
   border-top-width: 2px;
   font-style: italic;
/*   background-color: #FFF8DC; */
   font-weight: bold;
/*#FCDFFF;*/
}
th.thsa {
   border-left-width: 2px;
   border-right-width: 2px;
   background-color: lightyellow;
}
th.arch {
   border-top-width: 2px;
   font-style: italic;
   font-weight: normal;
}
th.direction {
   font-weight: normal;
}
td.best {
/*   background-color: #D8FBD8; */
}
td.algorithm {
   border-left-width: 2px;
   border-right-width: 2px;
   background-color: lightyellow;
}
.left {
   border-left-width: 2px;
}
.top {
   border-top-width: 2px;
}
.bottom {
   border-bottom-width: 2px;
}
.right {
   border-right-width: 2px;
}
td.descr {
/*   text-align: left; */
}
span.toc {
   margin-right: 20px;
   white-space: nowrap;
}
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
body { color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
.Statement { color: #af5f00; }
.Constant { color: #c00000; }
.Comment { color: #0000c0; }
.Type { color: #008000; }
</style>
</head>
<body>
<h1>cppcrypto library</h1>
<p>
<span class="toc"><a href="#chintro">1. Introduction</a></span>
<span class="toc"><a href="#chha">2. Hash algorithms</a></span>
<span class="toc"><a href="#chmac">3. MAC algorithms</a></span>
<span class="toc"><a href="#chbc">4. Block cipher algorithms</a></span>
<span class="toc"><a href="#chem">5. Block cipher encryption modes</a></span>
<span class="toc"><a href="#chsc">6. Stream cipher algorithms</a></span>
<span class="toc"><a href="#chkdf">7. Key derivation functions</a></span>
<span class="toc"><a href="#chaead">8. AEAD</a></span>
<span class="toc"><a href="#chsaead">9. Streaming AEAD</a></span>
<span class="toc"><a href="#chdu">10. Digest utility</a></span>
<span class="toc"><a href="#chcryptor">11. Cryptor utility</a></span>
<span class="toc"><a href="#chpn">12. Portability notes</a></span>
<span class="toc"><a href="#chdl">13. Download link</a></span>
</p>
<h2 id="chintro">1. Introduction</h2>
<p>cppcrypto is a small cross-platform BSD-licensed C++ library providing some cryptographic primitives. It has no external dependencies.</p>
<p>The library thrives to be as fast as possible. CPU type is detected at runtime and the fastest implementation is selected dynamically.</p>
<p><b>Supported compilers:</b> Visual C++ 2013 or later on Windows; gcc 5.1.1 or later, clang 3.4.1 or later on Linux, OS X, FreeBSD.
<br><b>Supported architectures:</b> x86_64 and x86.</p>
<p><a href="https://sourceforge.net/projects/cppcrypto/files">Download cppcrypto from sourceforge</a></p>
<p>Full list of supported cryptographic primitives is described below.
<h2 id="chha">2. Hash algorithms</h2>
<h3>2.1. Interface description</h3>
<p>All hash algorithms derive from <code>crypto_hash</code> class and implement its interface.</p>
<pre>
    class crypto_hash
    {
    public:
        virtual void init() = 0;
        virtual void update(const unsigned char* data, size_t len) = 0;
        virtual void final(unsigned char* hash) = 0;

        virtual size_t hashsize() const = 0;
        virtual size_t blocksize() const = 0;

        // Convenience functions
        void hash_string(const unsigned char* data, size_t len, unsigned char* hash);
        void hash_string(const char* data, size_t len, unsigned char* hash);
        void hash_string(const std::string& data, unsigned char* hash);
    };
</pre>
<p>If you have a short message, you can calculate the hash using a single <code>hash_string()</code> call.
Otherwise, call <code>init()</code> to start hashing,
then call <code>update()</code> any number of times to add the next chunk of data, and finally call <code>final()</code> to get the hash.
<br>The <code>hash</code> parameter should point to a buffer large enough to accept the hash of correspondent size (length in bytes is <code>hashsize()/8</code>).</p>
<h3>2.2. Supported algorithms</h3>
<p>Classes derived from <code>crypto_hash</code>:</p>
<table>
<tr><th>Class Name</th><th>Description</th><th>Supported output sizes</th></tr>
<tr>
<td><code>blake</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/BLAKE_%28hash_function%29">BLAKE</a></b> hash function (one of SHA-3 finalists).<br>This is one of the fastest hash functions and we recommend it you are free to choose.</td><td>224 / 256 / 384 / 512</td>
</tr>
<tr>
<td><code>blake2b</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/BLAKE_%28hash_function%29#BLAKE2">BLAKE2b</a></b> hash function with variable output size up to 512 bits.<br>This is a version of BLAKE-512 with reduced number of rounds and other simplifications.</td><td>8 - 512</td>
</tr>
<tr>
<td><code>blake2s</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/BLAKE_%28hash_function%29#BLAKE2">BLAKE2s</a></b> hash function with variable output size up to 256 bits.<br>This is a version of BLAKE-256 with reduced number of rounds and other simplifications.</td><td>8 - 256</td>
</tr>
<tr>
<td><code>echo</code></td>
<td class="descr"><b>ECHO</b> hash function (one of SHA-3 Round 2 candidates).</td><td>8 - 512</td>
</tr>
<tr>
<td><code>esch</code></td>
<td class="descr"><b>Esch</b> hash function (one of NIST Lightweight Crypto Competition finalists).</td><td>256 / 384</td>
</tr>
<tr>
<td><code>groestl</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Gr%C3%B8stl">Grøstl</a></b> hash function (one of SHA-3 finalists).</td><td>8 - 512</td>
</tr>
<tr>
<td><code>jh</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/JH_%28hash_function%29">JH</a></b> hash function (one of SHA-3 finalists).</td><td>224 / 256 / 384 / 512</td>
</tr>
<tr>
<td><code>kupyna</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Kupyna">Kupyna</a></b> hash function (Ukrainian national standard DSTU 7564:2014) with output sizes 256/512 bits.<br>224/384-bit functions are not provided because their output is identical to the truncated 256/512-bit output.</td><td>256 / 512</td>
</tr>
<tr>
<td><code>md5</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/MD5">MD5</a></b> hash function. Not secure and therefore not recommended; use only if you need it for compatibility.</td><td>128</td>
</tr>
<tr>
<td><code>sha1</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a></b> hash function. Not secure and therefore not recommended; use only if you need it for compatibility.</td><td>160</td>
</tr>
<tr>
<td><code>sha224</code><br><code>sha256</code><br><code>sha384</code><br><code>sha512</code><br></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/SHA-2">SHA-2</a></b> hash function (NIST standard FIPS 180-4).
<br>Individual functions are known as SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256.
<br>SHA-512 supports variable output size up to 512 bits (SHA-512/t).
<br><code>sha512(224)</code> and <code>sha512(256)</code> are faster than <code>sha224</code> and <code>sha256</code> on 64-bit platforms.
</td><td>224 / 256 / 384 / 512,<br>8 - 512 (SHA-512/t)</td>
<!--<td class="descr"><b>SHA-2</b> hash function (NIST standard FIPS 180-4).<br>New functions <code>sha512_224</code> and <code>sha512_256</code> from the latest revision of the standard are faster than <code>sha224</code> and <code>sha256</code> on 64-bit platforms.</td>-->
</tr>
<tr>
<td><code>sha3</code><br><code>shake128</code><br><code>shake256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/SHA-3">SHA-3</a></b> hash function (NIST standard FIPS 202) based on Keccak algorithm.
<br>SHAKE-128 and SHAKE-256 support variable output size.
<br>cSHAKE-128 and cSHAKE-256 as defined by NIST SP 800-185 are also supported.
</td><td>224 / 256 / 384 / 512 (SHA-3)<br>arbitrary (SHAKE)</td>
</tr>
<tr>
<td><code>skein256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Skein_%28hash_function%29">Skein</a></b> hash function (one of SHA-3 finalists) with block size 256 bits and variable output size.<br>This algorithm is slower than <code>skein512</code> on modern PCs, so use it only if you need them for compatibility.</td><td>arbitrary</td>
</tr>
<tr>
<td><code>skein512</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Skein_%28hash_function%29">Skein</a></b> hash function (one of SHA-3 finalists) with block size 512 bits and variable output size.<br>This is one of the fastest hash functions and we recommend it if you are free to choose.</td><td>arbitrary</td>
</tr>
<tr>
<td><code>skein1024</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Skein_%28hash_function%29">Skein</a></b> hash function (one of SHA-3 finalists) with block size 1024 bits and variable output size.</td><td>arbitrary</td>
</tr>
<tr>
<td><code>sm3</code></td>
<td class="descr"><b>SM3</b> hash function (Chinese national standard)</td><td>256</td>
</tr>
<tr>
<td><code>streebog</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Streebog">Streebog</a></b> hash function (Russian standard GOST R 34.11-2012)</td><td>256 / 512</td>
</tr>
<tr>
<td><code>whirlpool</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Whirlpool_%28cryptography%29">Whirlpool</a></b> hash function (recommended by NESSIE)</td><td>512</td>
</tr>
</table>
<p>MD5 and SHA-1 algorithms are broken and should not be used for new applications. We do not recommend using Streebog because of possible back door in the algorithm. All other supported hash functions are unbroken and safe to use.</p>
<h3>2.3. Usage example</h3>
<p>The following snippet calculates BLAKE-256 hash of a string using a single function call:</p>
<pre>
    unsigned char hash[256/8];
    blake(256).hash_string("The quick brown fox jumps over the lazy dog", hash);
    // Now <i>hash</i> contains the hash
</pre>
<p>The following snippet demonstrates how to calculate the hash of a very long message using the init/update/final interface:</p>
<p></p>
<pre>
    blake(256) hasher;
    unsigned char hash[256/8];
    
    hasher.init();
    hasher.update(datachunk1, chunk1len);
    hasher.update(datachunk2, chunk2len);
    ...
    hasher.final(hash); // Now <i>hash</i> contains the hash
</pre>
<h2 id="chmac">3. MAC algorithms</h2>
<h3>3.1. Interface description</h3>
<p>Class <code>crypto_mac</code> is similar to <code>crypto_hash</code>. The only difference is that you need to pass a key to the <code>init</code> method.
<p>All MAC algorithms derive from <code>crypto_mac</code> class and implement its interface.</p>
<pre>
    class crypto_mac
    {
    public:
        virtual void init(const unsigned char* key, size_t keylen) = 0;
        virtual void update(const unsigned char* data, size_t len) = 0;
        virtual void final(unsigned char* hash) = 0;

        virtual size_t keysize() const = 0;
        virtual size_t hashsize() const = 0;
        virtual size_t blocksize() const = 0;

        // Convenience functions
        void mac_string(const unsigned char* key, size_t key_len, const unsigned char* data, size_t len, unsigned char* hash);
        void mac_string(const char* key, size_t key_len, const unsigned char* data, size_t len, unsigned char* hash);
        void mac_string(const char* key, size_t key_len, const char* data, size_t len, unsigned char* hash);
        void mac_string(const std::string& key, const std::string& data, unsigned char* hash);
    };
</pre>
<p>If you have a short message, you can calculate the MAC using a single <code>mac_string()</code> call.
Otherwise, call <code>init()</code> to start hashing,
then call <code>update()</code> any number of times to add the next chunk of data, and finally call <code>final()</code> to get the MAC.
<br>The <code>hash</code> parameter should point to a buffer large enough to accept the MAC of correspondent size (length in bytes is <code>hashsize()/8</code>).</p>
<h3>3.2 HMAC</h3>
<p>Class <code>hmac</code> is derived from <code>crypto_mac</code>. To specify the underlying hash function, you need to pass a reference to the hash algorithm in the constructor.
<pre>
    hmac(const crypto_hash& hash);
</pre>
<p>The key can be of any length and you can use any of the supported hash algorithms to calculate HMAC. The following sample calculates HMAC-SHA-256 of a string &quot;The quick brown fox jumps over the lazy dog&quot; with key &quot;key&quot;:</p>
<pre>
    unsigned char hmackey[3];
    hmackey[0] = 'k';
    hmackey[1] = 'e';
    hmackey[2] = 'y';
    hmac mac(sha256());
    unsigned char result[32];
    mac.hash_string(hmackey, sizeof(hmackey), "The quick brown fox jumps over the lazy dog", result);
</pre>
<h3>3.3 Poly1305</h3>
<p>Class <code>poly1305</code> is also derived from <code>crypto_mac</code> and implements its interface.
<p>The key <b><i>must</i></b> have length 32 bytes (256 bits). The following sample calculates Poly1305 of a string &quot;The quick brown fox jumps over the lazy dog&quot; with key &quot;\x00\x01\x02...\x31&quot;:</p>
<pre>
    unsigned char key[32];
    std::iota(key, key + 32, 0);
    unsigned char result[16];
    poly.hash_string(key, sizeof(key), "The quick brown fox jumps over the lazy dog", result);
</pre>
<h2 id="chbc">4. Block cipher algorithms</h2>
<h3>4.1. Interface description</h3>
<p>All block cipher algorithms derive from <code>block_cipher</code> class and implement its interface.</p>
<pre>
    class block_cipher
    {
    public:
        enum direction { encryption, decryption };

        virtual size_t blocksize() const = 0;
        virtual size_t keysize() const = 0;

        virtual bool init(const unsigned char* key, block_cipher::direction direction) = 0;
        virtual void encrypt_block(const unsigned char* in, unsigned char* out) = 0;
        virtual void decrypt_block(const unsigned char* in, unsigned char* out) = 0;
    };
</pre>
<p>A low-level interface to the block cipher. To start encryption or decryption, call <code>init()</code> (<code>key</code> should point to a key of <code>keysize()/8</code> bytes), then call <code>encrypt_block()</code> or <code>decrypt_block()</code> to encrypt or decrypt a single block of <code>blocksize()/8</code> bytes.<br>
In practice in most cases you probably want to use block ciphers in an encryption mode via <code>cbc</code> or <code>ctr</code> class described below, or in AEAD mode described in a separate section.</p>
</html>
<h3>4.2. Supported algorithms</h3>
<p>Classes derived from <code>block_cipher</code>:</p>
<table>
<tr><th>Class Name</th><th>Description</th><th>Supported block sizes</th><th>Supported key sizes</th></tr>
<tr>
<td><code>anubis128</code><br><code>anubis160</code><br><code>anubis192</code><br><code>anubis224</code><br><code>anubis256</code><br><code>anubis288</code><br><code>anubis320</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Anubis_%28cipher%29">Anubis</a></b> cipher</td><td>128</td><td>128 / 160 / 192 / 224 / 256 / 288 / 320</td>
</tr>
<tr>
<td><code>aria128</code><br><code>aria192</code><br><code>aria256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/ARIA_%28cipher%29">Aria</a></b> cipher (South Korean national standard)</td><td>128</td><td>128 / 192 / 256</td>
</tr>
<tr>
<td><code>cast6_128</code><br><code>cast6_160</code><br><code>cast6_192</code><br><code>cast6_224</code><br><code>cast6_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/CAST-256">CAST6</a></b> (aka <b>CAST-256</b>) cipher</td><td>128</td><td>128 / 160 / 192 / 224 / 256</td>
</tr>
<tr>
<td><code>camellia128</code><br><code>camellia192</code><br><code>camellia256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Camellia_%28cipher%29">Camellia</a></b> cipher (recommended by NESSIE and CRYPTREC)</td><td>128</td><td>128 / 192 / 256</td>
</tr>
<tr>
<td><code>kalyna128_128</code><br><code>kalyna128_256</code><br><code>kalyna256_256</code><br><code>kalyna256_512</code><br><code>kalyna512_512</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Kalyna_(cipher)">Kalyna</a></b> cipher (Ukrainian national standard DSTU 7624:2014)</td><td>128 / 256 / 512</td><td>128 / 256 / 512</td>
</tr>
<tr>
<td><code>kuznyechik</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Kuznyechik">Kuznyechik</a></b> cipher (Russian national standard GOST R 34.12-2015)</td><td>128</td><td>256</td>
</tr>
<tr>
<td><code>mars128</code><br><code>mars160</code><br><code>mars192</code><br><code>mars224</code><br><code>mars256</code><br><code>mars288</code><br><code>mars320</code><br><code>mars352</code><br><code>mars384</code><br><code>mars416</code><br><code>mars448</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/MARS_%28cryptography%29">MARS</a></b> cipher (one of AES finalists)</td><td>128</td><td>128 / 160 / 192 / 224 / 256 / 288 / 320 / 352 / 384 / 416 / 448</td>
</tr>
<tr>
<td><code>rijndael128_128</code><br><code>rijndael128_160</code><br><code>rijndael128_192</code><br><code>rijndael128_224</code><br><code>rijndael128_256</code>
<br><code>rijndael160_128</code><br><code>rijndael160_160</code><br><code>rijndael160_192</code><br><code>rijndael160_224</code><br><code>rijndael160_256</code>
<br><code>rijndael192_128</code><br><code>rijndael192_160</code><br><code>rijndael192_192</code><br><code>rijndael192_224</code><br><code>rijndael192_256</code>
<br><code>rijndael224_128</code><br><code>rijndael224_160</code><br><code>rijndael224_192</code><br><code>rijndael224_224</code><br><code>rijndael224_256</code>
<br><code>rijndael256_128</code><br><code>rijndael256_160</code><br><code>rijndael256_192</code><br><code>rijndael256_224</code><br><code>rijndael256_256</code>
</td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael</a></b> cipher (AES winner)<br><br>Rijndael with block size 128 bits and key size 128, 192, 256 bits<br>is also known as<br> <b>AES-128, AES-192, AES-256</b>.<br><br>All 25 Rijndael variants are accelerated using AES-NI instructions,<br>if they are supported by CPU.</td><td>128 / 160 / 192 / 224 / 256</td><td>128 / 160 / 192 / 224 / 256</td>
</tr>
<tr>
<td><code>serpent128</code><br><code>serpent192</code><br><code>serpent256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Serpent_%28cipher%29">Serpent</a></b> cipher (one of AES finalists)</td><td>128</td><td>128 / 192 / 256</td>
</tr>
<tr>
<td><code>simon128_128</code><br><code>simon128_192</code><br><code>simon128_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Simon_%28cipher%29">Simon</a></b> cipher</td><td>128</td><td>128 / 192 / 256</td>
</tr>
<tr>
<td><code>sm4</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/SMS4">SM4</a></b> cipher (Chinese national standard for Wireless LAN)</td><td>128</td><td>128</td>
</tr>
<tr>
<td><code>speck128_128</code><br><code>speck128_192</code><br><code>speck128_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Speck_%28cipher%29">Speck</a></b> cipher</td><td>128</td><td>128 / 192 / 256</td>
</tr>
<tr>
<td><code>threefish256_256</code><br><code>threefish512_512</code><br><code>threefish1024_1024</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Threefish">Threefish</a></b> cipher</td><td>256 / 512 / 1024</td><td>256 / 512 / 1024</td>
</tr>
<tr>
<td><code>twofish128</code><br><code>twofish192</code><br><code>twofish256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Twofish">Twofish</a></b> cipher (one of AES finalists)</td><td>128</td><td>128 / 192 / 256</td>
</tr>
</table>
<p>All supported ciphers are unbroken and safe to use, although we do not recommend using Kuznyechik because of possible back door.</p>
<h2 id="chem">5. Block cipher encryption modes</h2>
<p>Authenticated encryption modes are described later in a separate section.</p>
<h3>5.1. CBC mode</h3>
<p>Class <code>cbc</code> implements the following interface:</p>
<pre>
    cbc(const block_cipher& cipher);

    void init(const unsigned char* key, size_t keylen, const unsigned char* iv, size_t ivlen, block_cipher::direction direction);

    <i>// Functions writing output to preallocated raw buffer (the fastest)</i>
    void encrypt_update(const unsigned char* in, size_t len, unsigned char* out, size_t& resultlen);
    void encrypt_final(unsigned char* out, size_t& resultlen);
    void decrypt_update(const unsigned char* in, size_t len, unsigned char* out, size_t& resultlen);
    void decrypt_final(unsigned char* out, size_t& resultlen);

    <i>// Functions writing output to std::vector (slower)</i>
    void encrypt_update(const unsigned char* in, size_t len, std::vector&lt;unsigned char&gt;& out);
    void encrypt_final(std::vector<unsigned char>& out);
    void decrypt_update(const unsigned char* in, size_t len, std::vector&lt;unsigned char&gt;& out);
    void decrypt_final(std::vector<unsigned char>& out);

    <i>// Functions writing output to std::ostream (the slowest)</i>
    void encrypt_update(const unsigned char* in, size_t len, std::ostream& out);
    void encrypt_final(std::ostream& out);
    void decrypt_update(const unsigned char* in, size_t len, std::ostream& out);
    void decrypt_final(std::ostream& out);
</pre>
<p>The functions are similar to the ones from the <code>crypto_hash</code> class.</p><p>To start encryption, pass one of the block ciphers to the constructor and initialize encryption using <code>init()</code> function. The length of the key in bytes should be equal to <code>keysize()/8</code> of the block cipher, and the length of the initialization vector (<code>iv</code>) in bytes should be equal to <code>blocksize()/8</code> of the block cipher. Then call <code>encrypt_update()</code> any number of times to add the next chunk of data of variable length. When all input is consumed by <code>encrypt_update()</code> function, call <code>encrypt_final()</code> to finish the encryption (at this stage the final block will be written to <code>out</code>).
<p>Decryption is done in a similar way.</p>
<p>If you use the low-level functions that write the output to a preallocated buffer, the <code>out</code> argument should point to the next location where the encrypted output should be written; <code>resultlen</code> is the number of bytes written to <code>out</code> as the result of the function call. Because the class implements PKCS#7 padding, the overall size of the output buffer should be equal to the size of the input rounded up to the block size of the cipher algorithm, plus one additional full block if the input size is the exact multiple of the block size. It is responsibility of the caller to make sure the buffer is large enough.</p>
<p>A simpler but slower interface accepts a reference to <code>std::vector&lt;unsigned char&gt;</code> and appends encryption or decryption result to this vector, which is dynamically resized as needed, so that you do not need to calculate and allocate a buffer of proper size in advance.</p>
<p>An even simpler but slower interface writes the output to <code>std::ostream</code>.</p>
<p>Note that regardless of which interface you use, you still need to call <code>init()</code> function to set up the key and initialization vector.</p>
<h3>5.2. CTR mode</h3>
<p>Class <code>ctr</code> implements the <code>stream_cipher</code> interface for block ciphers:</p>
<pre>
    ctr(const block_cipher& cipher);

    void init(const unsigned char* key, size_t keylen, const unsigned char* iv, size_t ivlen);
    void encrypt(const unsigned char* in, size_t len, unsigned char* out);
    void decrypt(const unsigned char* in, size_t len, unsigned char* out);
</pre>
<p>CTR mode turns block cipher into a stream cipher, so no padding is needed in this mode and the size of the output buffer must be the same as the size of the input data.
The length of the key in bytes should be equal to <code>keysize()/8</code> of the block cipher, and the length of the initialization vector (<code>iv</code>) in bytes should be equal to or smaller than <code>blocksize()/8</code> of the block cipher.
Since all output is produced immediately, no finalization function is needed in this mode.</p>
<h2 id="chsc">6. Stream cipher algorithms</h2>
<h3>6.1. Interface description</h3>
<p>All stream cipher algorithms derive from <code>stream_cipher</code> class and implement its interface.</p>
<pre>
    class stream_cipher
    {
    public:
        virtual size_t keysize() const = 0;
        virtual size_t ivsize() const = 0;

        virtual void init(const unsigned char* key, size_t keylen, const unsigned char* iv, size_t ivlen) = 0;
        virtual void encrypt(const unsigned char* in, size_t len, unsigned char* out) = 0;
        virtual void decrypt(const unsigned char* in, size_t len, unsigned char* out) = 0;
    };
</pre>
<p>To start encryption or decryption, call <code>init()</code> (<code>key</code> should point to a key of <code>keysize()/8</code> bytes, and iv should point to an initialization vector of <code>ivsize()/8</code> bytes). Then call <code>encrypt()</code> or <code>decrypt()</code> to encrypt or decrypt a stream of any length.</p>
</html>
<h3>6.2. Supported algorithms</h3>
<p>Classes derived from <code>stream_cipher</code>:</p>
<table>
<tr><th>Class Name</th><th>Description</th><th>Supported key sizes</th><th>Supported IV/nonce sizes</th></tr>
<tr>
<td><code>chacha20_128</code><br><code>chacha20_256</code><br><code>chacha12_128</code><br><code>chacha12_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Salsa20#ChaCha_variant">ChaCha</a></b> cipher (a variant of Salsa20)
<br>including full 20-round version and reduced 12-round version</td><td>128 / 256</td><td>64</td>
</tr>
<tr>
<td><code>hc128</code><br><code>hc256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/HC-256">HC</a></b> cipher (member of eSTREAM portfolio)</td><td>128 / 256</td><td>128 / 256</td>
</tr>
<tr>
<td><code>salsa20_128</code><br><code>salsa20_256</code><br><code>salsa20_12_128</code><br><code>salsa20_12_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Salsa20">Salsa20</a></b> cipher (member of eSTREAM portfolio)
<br>including full 20-round version and reduced 12-round version</td><td>128 / 256</td><td>64</td>
</tr>
<tr>
<td><code>xchacha20_128</code><br><code>xchacha20_256</code><br><code>xchacha12_128</code><br><code>xchacha12_256</code></td>
<td class="descr"><b>XChaCha</b> cipher (a variant of ChaCha with longer nonce)
<br>including full 20-round version and reduced 12-round version</td><td>128 / 256</td><td>192</td>
</tr>
<tr>
<td><code>xsalsa20_128</code><br><code>xsalsa20_256</code><br><code>xsalsa20_12_128</code><br><code>xsalsa20_12_256</code></td>
<td class="descr"><b>XSalsa20</b> cipher (a variant of Salsa20 with longer nonce)
<br>including full 20-round version and reduced 12-round version</td><td>128 / 256</td><td>192</td>
</tr>
</table>
<p>You can also use any of the supported block ciphers like a stream cipher via <code>ctr</code> class, which implements the same <code>stream_cipher</code> interface.</p>
<h2 id="chkdf">7. Key derivation functions</h2>
<p>You can use KDF functions to derive an encryption key from a password or other input key material (depending on the function).</p>
<h3>7.1. Interface description</h3>
<p>All KDF algorithms derive from <code>crypto_kdf</code> class and implement its interface.</p>
<pre>
    class crypto_kdf
    {
    public:
	virtual void derive_key(const unsigned char* ikm, size_t ikm_len, const unsigned char* random_data, size_t random_data_len, unsigned char* dk, size_t dklen) = 0;

	void gen_random_data_and_derive_key(const unsigned char* ikm, size_t ikm_len, size_t random_data_len, unsigned char* random_data, unsigned char* dk, size_t dklen);
    };
</pre>
<p>Method <code>gen_random_data_and_derive_key</code> will generate random salt of length <code>random_data_len</code> and write it to <code>random_data</code>.
It will then derive a key of length <code>dklen</code> from the input key material <code>ikm</code> and write it to <code>dk</code>.</p>
<p>Method <code>derive_key</code> does the same, except that it derives a key using random salt passed as a parameter instead of generating random salt internally.</p>
<h3>7.2. PBKDF2</h3>
<p><a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a> is an old password-based key derivation function. Use it only if you need one for compatibility, otherwise prefer <code>scrypt</code> or <code>argon2</code>.</p>
<p>The following snippet generates a 256-bit key from password "password" and salt "salt" using PBKDF2 algorithm with 100000 iterations of HMAC-SHA256:</p>
<pre>
    unsigned char key[256 / 8];
    pbkdf2(sha256(), 100000).derive_key((const unsigned char*)"password", 8, (const unsigned char*)"salt", 4, key, sizeof(key));
</pre>
<h3>7.3. scrypt</h3>
<p>Function <a href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a> has the following prototype:</p>
<pre>
    class scrypt : public crypto_kdf
    {
    public:
        <i>/*
           Scrypt key derivation function.
           Parameters:
           hash    Hash to use for HMAC (e.g. SHA-256).
           N       CPU/Memory cost parameter, must be larger than 1, a power of 2 and less than 2^(16*r).
           r       Block size factor parameter.
           p       Parallelization parameter, a positive integer less than (2^30)/r.
        */</i>
        scrypt(const crypto_hash& hash, size_t N, size_t r, size_t p);

        <i>// Change CPU/Memory cost parameter, must be larger than 1, a power of 2 and less than 2^(16*r)</i>
        void set_N(size_t N);

        <i>// Change Block size factor parameter.</i>
        void set_r(size_t r);

        // Change Parallelization parameter, a positive integer less than (2^30)/r.
        void set_p(size_t p);

        /*
           Derive a key from a password.

           Input:
           password Passphrase.
           salt     Salt.
           dklen    Intended output length of the derived key, given in bytes.

           Output:
           dk       Derived key, of length dklen bytes.
	*/
        void derive_key(const unsigned char* password, size_t password_len, const unsigned char* salt, size_t salt_len, unsigned char* dk, size_t dklen) const override;
	};
</pre>
<p>You can use this function to derive an encryption key from a password.</p>
<p>The following snippet generates a 256-bit key from password "password" and salt "salt" using scrypt with N=16384, r=8 and p=16 (which takes 0.10 seconds on Intel Xeon E5-1650 v3):</p>
<pre>
    unsigned char key[256 / 8];
    scrypt(sha256(), 16384, 8, 16).derive_key((const unsigned char*)"password", 8, (const unsigned char*)"salt", 4, key, sizeof(key));
</pre>
<h3>7.4. Argon2</h3>
<p><a href="https://en.wikipedia.org/wiki/Argon2">Argon2</a> is a winner of Password Hashing Competition and is the recommended function for hashing passwords.</p>
<p>There are three versions of Argon2 function: <code>argon2i</code>, <code>argon2d</code> and <code>argon2id</code>. Argon2i is the safest against side-channel attacks, while Argon2d provides the highest resistance against GPU cracking attacks.
If side-channel attachs are a concern, use Argon2i, otherwise, use Argon2d. If in doubt, use Argon2id.</p>
<pre>
    class argon2 : public crypto_kdf
    {
    public:
        enum class type
        {
            argon2d = 0,
            argon2i = 1,
            argon2id = 2
        };

        </i>/*
           Argon2 key derivation function.
           Parameters:
           type     Argon2 variant (argon2i, argon2d or argon2id).
           p        A parallelism degree, which defines the number of parallel threads.
           m        A memory cost, which defines the memory usage, given in kibibytes.
           t        A time cost, which defines the amount of computation realized and therefore the execution time, given in number of iterations.
        */</i>
        argon2(type type, uint32_t parallelism_degree = 4, uint32_t memory_cost = 4096, uint32_t time_cost = 1000);

        </i>// Change parallelism parameter (number of parallel threads).</i>
        void set_parallelism_degree(uint32_t parallelism_degree);

        </i>// Change memory cost parameter (memory usage in kibibytes).</i>
        void set_memory_cost(uint32_t memory_cost);

        </i>// Change time cost parameter (number of iterations).</i>
        void set_time_cost(uint32_t time_cost);

        </i>/*
           Derive a key from a password.

           Input:
           password Passphrase.
           salt     Salt.
           dklen    Intended output length of the derived key, given in bytes.

           Optional input:
           data     Associated data which will affect the derived key.
           secret   Secret value which will affect the derived key.

           Output:
           dk       Derived key, of length dklen bytes.
        */</i>
        void derive_key(const char* password, uint32_t pwd_len, const unsigned char* salt, uint32_t salt_len, unsigned char* dk, uint32_t dklen,
                        unsigned char* data = nullptr, uint32_t datalen = 0, unsigned char* secret = nullptr, uint32_t secretlen = 0);

    };
</pre>
<p>The following snippet generates a 256-bit key from password "password" and salt "salt" using <code>argon2i</code> function with p=4, m=4096 and t=1000 (which takes 0.68 seconds on Intel Xeon E5-1650 v3):</p>
<pre>
    unsigned char key[256 / 8];
    argon2(argon2::type::argon2i, 4, 4096, 1000).derive_key("password", 8, (const unsigned char*)"salt", 4, key, sizeof(key));
</pre>
<p>Our implementation of Argon2 is faster than the optimized reference implementation, which needs 1.05 seconds to compute the same Argon2i hash on the same PC (both implementations were compiled by VC++ 2015 with /O2 optimization).</p>
<h3>7.5. HKDF</h3>
<p><a href="https://en.wikipedia.org/wiki/HKDF">HKDF</a> is a key derivation function based on HMAC.</p>
<p>It can be used to extract randomness from the source key material and/or expand the key into a larger output, for example, to create multiple keys from a single key.</p>
<p>Note that HKDF is not suitable for generating keys from passwords. For that purpose, use password-based KDFs such as <code>argon2</code>.</p>
<pre>
class hkdf : public crypto_kdf
{
public:
        hkdf(const crypto_hash& hash);

        <i>/*
           Extract pseudorandom key from source key material and optional extractor salt.

           Input:
           skm      Source key material (must not be a password).
           xts      Extractor salt (optional).
           prk_len  Length of the extracted key in bytes. Must be equal to hash size of the hash function.

           Output:
           prk      Extracted pseudo-random key.
	*/</i>
	void extract(const unsigned char* xts, size_t xts_len, const unsigned char* skm, size_t skm_len, unsigned char* prk, size_t prk_len);

        <i>/*
           Expand pseudorandom key into desired size.

           Input:
           prk      Pseudorandom key to be expanded.
           ctxinfo  Context information.
           okm_len  Length of the output keying material in bytes.

           Output:
           okm      Output keying material (expanded key).
        */</i>
        void expand(const unsigned char* prk, size_t prk_len, const unsigned char* ctxinfo, size_t ctxinfo_len, unsigned char* okm, size_t okm_len);

        <i>/*
           Extract pseudorandom key from source key material and optional extractor salt, then expand pseudorandom key into desired size.

           Input:
           skm      Source key material (must not be a password).
           xts      Extractor salt (optional).
           ctxinfo  Context information.
           okm_len  Length of the output keying material in bytes.

           Output:
           okm      Output keying material (expanded key).
        */</i>
        void extract_and_expand(const unsigned char* xts, size_t xts_len, const unsigned char* ctxinfo, size_t ctxinfo_len, const unsigned char* skm, size_t skm_len, unsigned char* okm, size_t okm_len);

        <i>/*
           Derive key from the input key material and random data. Implements the crypto_kdf interface. The key will be derived via extract_and_expand.
           This method does not allow to specify extractor salt, if it is needed, use extract_and_expand directly.

           Input:
           ikm         Input key material. Must not be a password. Will be used passed as a source key material to extract_and_expand.
           random_data Random data. Will be passed as context information to extract_and_expand.
           okm_len     Length of the derived key in in bytes.

           Output:
           dk          Derived key.
        */</i>
        virtual void derive_key(const unsigned char* ikm, size_t ikm_len, const unsigned char* random_data, size_t random_data_len, unsigned char* dk, size_t dklen) override;

        <i>/*
           Initial counter value for the Expand stage.
           By default the initial counter value is 1, as specified in RFC 5869.
           If compatibility with RFC the original paper is needed, it can be changed to 0.
        */</i>
        void set_initial_counter_value(uint8_t counter);
};
</pre>
<h2 id="chaead">8. Authenticated encryption with associated data (AEAD)</h2>
<h3>8.1. Interface description</h3>
<p>All AEAD algorithms derive from <code>aead</code> class and implement its interface.</p>
<pre>
    class aead
    {
    public:
	// key setup
	virtual void set_key(const unsigned char* key, size_t keylen) = 0;

	// encrypt
	void encrypt(const unsigned char* plaintext, size_t plaintext_len, const unsigned char* associated_data, size_t associated_data_len, unsigned char* result, size_t result_buffer_len);
	void encrypt_with_explicit_iv(const unsigned char* plaintext, size_t plaintext_len, const unsigned char* associated_data, size_t associated_data_len, const unsigned char* iv, size_t iv_len, unsigned char* result, size_t result_buffer_len);

	// decrypt 
	bool decrypt(const unsigned char* ciphertext, size_t ciphertext_len, const unsigned char* associated_data, size_t associated_data_len, unsigned char* result, size_t result_buffer_len);
	bool decrypt_with_explicit_iv(const unsigned char* ciphertext, size_t ciphertext_len, const unsigned char* associated_data, size_t associated_data_len, const unsigned char* iv, size_t iv_len, unsigned char* result, size_t result_buffer_len);

	// informational getters
	virtual size_t key_bytes() const = 0;
	virtual size_t iv_bytes() const = 0;
	virtual size_t tag_bytes() const = 0;
    };
</pre>
<p>To encrypt and tag plaintext, use <code>encrypt</code> function which will generate a random initializatio vector of required size and prepend it to the ciphertext. This is the recommended mode for most use cases. Buffer for the result must be preallocated in advance. Required buffer size for the result buffer is equal to the <code>plaintext_len</code> plus <code>tag_bytes()</code> plus <code>iv_bytes()</code>.</p>
<p>If you need to use your own initialization vector, you can use <code>encrypt_with_explicit_iv</code> funtion. This function won't prepend initialization vector to the ciphertext, so the required buffer size for the result buffer is <code>plaintext_len</code> plus <code>tag_bytes()</code>.</p>
<p>Required buffer size for <code>decrypt</code> function is <code>ciphertext_len</code> minus <code>tag_bytes()</code> minus <code>iv_bytes()</code>.</p>
<p>Required buffer size for <code>decrypt_with_explicit_iv</code> function is <code>ciphertext_len</code> minus <code>tag_bytes()</code>.</p>
<p>The key should be set before encryption or decryption via <code>set_key()</code> method.</p>

<h3>8.2. Encrypt-then-MAC</h3>
<p><a href="https://en.wikipedia.org/wiki/Authenticated_encryption#Encrypt-then-MAC">Encrypt-then-MAC (EtM)</a> is a universal AEAD mode which can be used to combine any block cipher in <code>ctr</code> encryption mode, or any stream cipher, with any MAC function to create a secure AEAD construction.</p>
<p>This mode is implemented by <code>aead_etm</code> class. Cipher and MAC algorithms should be passed to the constructor. The size of the key passed to <code>set_key</code> function must be equal to the sum of cipher key size and MAC key size.</p>
<p>Some examples:</p>
<pre>
	aead_etm etm1(ctr(rijndael128_256()), (hmac(sha256()))); <i>// AES-256-HMAC-SHA-256</i>
	aead_etm etm2(ctr(rijndael128_128()), hmac(sha512(128))); <i>// AES-128-HMAC-SHA-512/128</i>
	aead_etm etm3(ctr(rijndael160_224()), hmac(blake(224))); <i>// Rijndael-160-224-HMAC-BLAKE-224</i>
	aead_etm etm4(ctr(serpent256()), hmac(groestl(256))); <i>// Serpent-256-HMAC-Grøstl-256</i>
	aead_etm etm5(xsalsa20_256(), (poly1305())); <i>// XSalsa20/20-Poly1305</i>
	aead_etm etm6(ctr(simon128_128()), (poly1305())); <i>// Simon-128-Poly1305</i>
	aead_etm etm7(ctr(anubis256()), hmac(jh(256))); <i>// Anubis-256-HMAC-JH-256</i>
	<i>// ...</i>
	<i>// Any combination possible!</i>
</pre>
<p>In addition to the generic Encrypt-then-MAC AEAD, cppcrypto implements some specific AEAD modes described below.</p>
<h3>8.3. GCM</h3>
<p><a href="https://en.wikipedia.org/wiki/Galois/Counter_Mode">Galois-Counter Mode (GCM)</a> is an AEAD mode which can be used with any block cipher with block size of 128 bits.</p>
<p>This mode is implemented by <code>aead_gcm</code> class. Block cipher should be passed to the constructor.</p>
<p>Some examples:</p>
<pre>
	aead_gcm gcm1((rijndael128_256())); <i>// AES-256-GCM</i>
	aead_gcm gcm2((serpent256())); <i>// Serpent-256-GCM</i>
	aead_gcm gcm3((camellia192())); <i>// Camellia-192-GCM</i>
	<i>// ...</i>
</pre>
<h3>8.4. OCB</h3>
<p><a href="https://en.wikipedia.org/wiki/OCB_mode">Offset Codebook (OCB)</a> is an AEAD mode which can be used with any block cipher of any block size.</p>
<p>This mode is implemented by <code>aead_ocb</code> class. Block cipher should be passed to the constructor.</p>
<p>Some examples:</p>
<pre>
	aead_ocb ocb1((rijndael128_256())); <i>// AES-256-OCB-TAGLEN128</i>
	aead_ocb ocb2((rijndael128_256()), 96); <i>// AES-256-OCB-TAGLEN96</i>
	aead_ocb ocb3((serpent256())); <i>// Serpent-256-OCB-TAGLEN128</i>
	aead_ocb ocb4((rijndael224_256())); <i>// Rijndael-224-256-OCB-TAGLEN224</i>
	aead_ocb ocb5((threefish512_512())); <i>// Threefish-512-OCB-TAGLEN256</i>
	<i>// ...</i>
</pre>
<h3>8.5. IETF-ChaCha-Poly</h3>
<p><a href="https://en.wikipedia.org/wiki/ChaCha20-Poly1305">IETF-ChaCha-Poly1305</a> is an AEAD mode which combines <code>chacha20_256</code> stream cipher with <code>poly1305</code> message authentication code.</p>
<p>While <code>chacha20_256</code> and <code>poly1305</code> can also be combined via generic <code>aead_etm</code> combiner, <code>aead_ietf_chacha_poly</code> is provided for compatibility with RFC-8439.
There are several minor differences between using <code>aead_ietf_chacha_poly</code> and combining <code>chacha20_256</code> and <code>poly1305</code> via <code>aead_etm</code>.
The biggest difference is that <code>aead_ietf_chacha_poly</code> requires a single 256-bit key and derives Poly1305 key from it using ChaCha, while <code>aead_etm</code> requires a combined key, the first half of which is used for ChaCha and the second half is used for Poly1305.
Additionally, there are some minor differences in the pre-authentication encoding, for example, <code>aead_ietf_chacha_poly</code> pads plaintext and associated data to 16-byte boundary while <code>aead_etm</code> does not.</p>
<p>From the security standpoint there is no difference, both options are secure, so if you do not need compatibility with RFC-8439, you can just as well use the universal <code>aead_etm</code> combiner.
<p><code>aead_ietf_chacha_poly</code> can be used not only with <code>chacha20_256</code>, but also with any variant of ChaCha or Salsa20, for example, with extended-nonce variant <code>xchacha20_256</code>. Just pass the required cipher variant to the constructor of <code>aead_ietf_chacha_poly</code>.</p>
<p>Examples:</p>
<pre>
	aead_ietf_chacha_poly aead1;  <i>// chacha20-poly1305</i>
	aead_ietf_chacha_poly aead2((xchacha20_256())); <i>// xchacha20-poly1305</i>
	aead_ietf_chacha_poly aead3((salsa20_256())); <i>// xsalsa20/20-poly1305</i>
	aead_ietf_chacha_poly aead4((salsa20_12_128())); <i>// xsalsa20/12/128-poly1305</i>
</pre>
<h3>8.6. Schwaemm</h3>
<p><b>Schwaemm</b> is one of the finalists of the NIST Lightweight Cryptography Competition. We support three out of four proposed instances: schwaemm256-256, schwaemm256-128 and schwaemm192-192. All instances are implemented via <code>schwaemm</code> class.</p>
<p>Examples:</p>
<pre>
	schwaemm aead1(schwaemm::variant::schwaemm256_256);
	schwaemm aead2(schwaemm::variant::schwaemm256_128);
	schwaemm aead3(schwaemm::variant::schwaemm256_192);
</pre>


<h2 id="chsaead">9. Streaming authenticated encryption with associated data (Streaming AEAD)</h2>
<p>Class <code>streaming_aead</code> can be used to convert any <code>aead</code> into streaming (segmented) AEAD in order to encrypt/decrypt large input using multiple segments. Each segment will be authenticated separately and will have its own authentication tag.</p>
<p>Streaming AEAD is useful for encrypting large files or other data that is too big to be encrypted in one step. The implementation uses the approach described in paper <a href="https://eprint.iacr.org/2015/189.pdf">Online Authenticated-Encryption and its Nonce-Reuse Misuse-Resistance</a>.
It is similar but not identical to libsodium's crypto_secretstream or Google Tink's Streaming AEAD.</p>
<p>To start streaming encryption, call <code>init_encryption()</code>, which creates the stream header, then call <code>encrypt_segment()</code> for each segment that needs to be encrypted. The last call to <code>encrypt_segment</code> must indicate that the segment being encrypted is the final segment of the stream.</p>
<p>Segments can be of any size and different segments can have different sizes, however, the encryption code should match the decryption code. For example, if the encryption code encrypts a segment of 1 Mb followed by another segment of 4 Kb, then the decryption code should also decrypt a segment of 1 Mb (enlarged by <code>tag_bytes()</code>) followed by another segment of 4 Kb (enlarged by <code>tag_bytes()</code>).</p>
<p>The encryption key is generated internally from the input key material using random salt and specified key derivation function. If you already have a key (not a password), you can use <code>hkdf</code> as the key derivation function. If you have a password, use password based kdf such as <code>argon2</code>.</p>
<p>Format of the generated stream header is:
<ul><li>header size in bytes (1 byte);</li><li>random salt (size equal to <code>salt_bytes()</code>);</li><li>random nonce prefix (size equal to <code>nonce_prefix_bytes()</code>).</li></ul></p>
<p>Format of the generated stream is:<ul><li>header of size <code>header_bytes()</code></li><li>ciphertext 1 with authentication tag 1</li><li>ciphertext 2 with authentication tag 2</li><li>...</li><li>ciphertext N with authentication tag N</li></ul></p>
<p>Each segment is encrypted using encryption key generated as described above and nonce. Nonce has the following format:<ul><li>nonce prefix from the stream header</li><li>segment counter (4 bytes)</li><li>final segment flag (1 byte)</li><li>block counter (4 bytes, present only if the underlying AEAD is a CTR mode with MAC)</li></ul></p>
<p>To decrypt the stream, first call <code>init_decryption()</code> with the stream header, then call <code>decrypt_segment</code> for each segment. The last call to <code>decrypt_segment</code> must indicate that the segment being decrypted is the final segment of the stream.</p>
<p>The ciphertext for each segment is longer than plaintext by <code>tag_bytes()</code>. The overall stream size is longer than plaintext by <code>header_bytes()</code> + N * <code>tag_bytes()</code>, where N is the number of segments.</p>
<pre>
    class streaming_aead
    {
    public:
        enum class segment_type : uint8_t
        {
            non_final = 0,
            final = 1
        };

        streaming_aead(const aead& aead);

        ~streaming_aead();

        <i>// Initialize streaming authenticated encryption.
        // Must be done once before encryption or decryption.
        // The key will be derived from the input key material ikm using key derivation function kdf.
        // Header length must be equal to header_bytes().</i>
        void init_encryption(const unsigned char* ikm, size_t ikmlen, unsigned char* header, size_t header_len, const crypto_kdf& kdf = hkdf(sha256()));

        <i>// Initialize streaming authenticated decryption.
        // Must be done once before encryption or decryption.
        // The key will be derived from the input key material ikm using key derivation function kdf.
        // Header length must be equal to header_bytes().</i>
        void init_decryption(const unsigned char* ikm, size_t ikmlen, const unsigned char* header, size_t header_len, const crypto_kdf& kdf = hkdf(sha256()));

        <i>// Encrypt a segment.
        // The size of the result buffer must be equal to plaintext_len plus tag_bytes().
        // Type must be set to streaming_aead::segment_type::final for the last segment in the stream.</i>
        void encrypt_segment(segment_type type, const unsigned char* plaintext, size_t plaintext_len, const unsigned char* associated_data, size_t associated_data_len, unsigned char* result, size_t result_buffer_len);

        <i>// Decrypt a segment.
        // The size of the result buffer must be equal to ciphertext_len minus tag_bytes().
        // Type must be set to streaming_aead::segment_type::final for the last segment in the stream.</i>
        bool decrypt_segment(segment_type type, const unsigned char* ciphertext, size_t ciphertext_len, const unsigned char* associated_data, size_t associated_data_len, unsigned char* result, size_t result_buffer_len);

        <i>// informational getters</i>

        virtual size_t tag_bytes() const;
        virtual size_t header_bytes() const;
        virtual size_t nonce_prefix_bytes() const;
        virtual size_t salt_bytes() const;
    };

</pre>
<p>The following sample encrypts a file in segments of 1 Mb using Serpent algorithm with 256-bit key in CTR mode and authenticated using HMAC-Grøstl-256. The encryption key is derived from user-provided password using Argon2d key derivation function.</p>
<pre>
<span class="Type">void</span> encrypt_file(std::<span class="Type">string</span> in_filename, std::<span class="Type">string</span> out_filename, std::<span class="Type">string</span> password)
{
    <span class="Comment">// Initialize streaming AEAD encryption using password based key derivation function Argon2d</span>
    streaming_aead aead(aead_etm(ctr(serpent256()), hmac(groestl(<span class="Constant">256</span>))));
    argon2 kdf(argon2::type::argon2d, <span class="Constant">4</span>, <span class="Constant">4096</span>, <span class="Constant">1000</span>);
    std::<span class="Type">vector</span>&lt;<span class="Type">char</span>&gt; header(aead.header_bytes());
    aead.init_encryption(<span class="Statement">reinterpret_cast</span>&lt;<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span>*&gt;(password.data()), password.length(),
        <span class="Statement">reinterpret_cast</span>&lt;<span class="Type">unsigned</span> <span class="Type">char</span>*&gt;(&amp;header[<span class="Constant">0</span>]), header.size(), kdf);

    std::ifstream input_file(in_filename, std::ios::in | std::ios::binary);
    <span class="Statement">if</span> (!input_file)
    {
        std::cerr &lt;&lt; <span class="Constant">&quot;cannot open input file&quot;</span> &lt;&lt; std::endl;
        <span class="Statement">return</span>;
    }

    std::ofstream output_file(out_filename, std::ios::out | std::ios::binary);
    <span class="Statement">if</span> (!output_file)
    {
        std::cerr &lt;&lt; <span class="Constant">&quot;cannot open output file&quot;</span> &lt;&lt; std::endl;
        <span class="Statement">return</span>;
    }

    output_file.write(header.data(), header.size());

    <span class="Comment">// Encrypt a file in blocks of </span><span class="Constant">1</span><span class="Comment"> megabyte</span>
    std::<span class="Type">uintmax_t</span> segment_size = <span class="Constant">1024</span> * <span class="Constant">1024</span>;
    std::<span class="Type">uintmax_t</span> file_size = std::filesystem::file_size(in_filename);
    std::<span class="Type">uintmax_t</span> buffer_size = std::min(segment_size, file_size);
    std::<span class="Type">vector</span>&lt;<span class="Type">char</span>&gt; in_buffer(buffer_size), out_buffer(buffer_size + aead.tag_bytes());
    std::<span class="Type">uintmax_t</span> remaining = file_size;
    <span class="Statement">do</span>
    {
        segment_size = std::min(remaining, buffer_size);
        <span class="Statement">if</span> (!input_file.read(&amp;in_buffer[<span class="Constant">0</span>], segment_size))
        {
            std::cerr &lt;&lt; <span class="Constant">&quot;error reading input file&quot;</span> &lt;&lt; std::endl;
            <span class="Statement">return</span>;
        }
        <span class="Type">size_t</span> output_size = segment_size + aead.tag_bytes();
        aead.encrypt_segment(remaining == segment_size ? streaming_aead::segment_type::<span class="Type">final</span> : streaming_aead::segment_type::non_final,
            <span class="Statement">reinterpret_cast</span>&lt;<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span>*&gt;(in_buffer.data()), segment_size, <span class="Constant">nullptr</span>, <span class="Constant">0</span>,
            <span class="Statement">reinterpret_cast</span>&lt;<span class="Type">unsigned</span> <span class="Type">char</span>*&gt;(&amp;out_buffer[<span class="Constant">0</span>]), output_size);
        output_file.write(out_buffer.data(), output_size);
        remaining -= segment_size;
    } <span class="Statement">while</span> (remaining);
}

<span class="Type">void</span> decrypt_file(std::<span class="Type">string</span> in_filename, std::<span class="Type">string</span> out_filename, std::<span class="Type">string</span> password)
{
    <span class="Comment">// Initialize streaming AEAD encryption using password based key derivation function Argon2d</span>
    streaming_aead aead(aead_etm(ctr(serpent256()), hmac(groestl(<span class="Constant">256</span>))));
    argon2 kdf(argon2::type::argon2d, <span class="Constant">4</span>, <span class="Constant">4096</span>, <span class="Constant">1000</span>);

    std::<span class="Type">uintmax_t</span> file_size = std::filesystem::file_size(in_filename);
    <span class="Statement">if</span> (file_size &lt; aead.header_bytes() + aead.tag_bytes())
    {
        std::cerr &lt;&lt; <span class="Constant">&quot;Invalid input file&quot;</span> &lt;&lt; std::endl;
        <span class="Statement">return</span>;
    }

    std::ifstream input_file(in_filename, std::ios::in | std::ios::binary);
    <span class="Statement">if</span> (!input_file)
    {
        std::cerr &lt;&lt; <span class="Constant">&quot;cannot open input file&quot;</span> &lt;&lt; std::endl;
        <span class="Statement">return</span>;
    }

    std::<span class="Type">vector</span>&lt;<span class="Type">char</span>&gt; header(aead.header_bytes());
    <span class="Statement">if</span> (!input_file.read(&amp;header[<span class="Constant">0</span>], header.size()))
    {
        std::cerr &lt;&lt; <span class="Constant">&quot;Invalid input file&quot;</span> &lt;&lt; std::endl;
        <span class="Statement">return</span>;
    }

    aead.init_decryption(<span class="Statement">reinterpret_cast</span>&lt;<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span>*&gt;(password.data()), password.length(),
        <span class="Statement">reinterpret_cast</span>&lt;<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span>*&gt;(&amp;header[<span class="Constant">0</span>]), header.size(), kdf);

    <span class="Comment">// Decrypt a file in blocks of </span><span class="Constant">1</span><span class="Comment"> megabyte</span>
    std::<span class="Type">uintmax_t</span> segment_size = <span class="Constant">1024</span> * <span class="Constant">1024</span>;
    std::<span class="Type">uintmax_t</span> remaining = file_size - aead.header_bytes();
    std::<span class="Type">uintmax_t</span> buffer_size = std::min(segment_size + aead.tag_bytes(), remaining);
    std::<span class="Type">vector</span>&lt;<span class="Type">char</span>&gt; in_buffer(buffer_size), out_buffer(buffer_size - aead.tag_bytes());
    std::ofstream output_file(out_filename, std::ios::out | std::ios::binary);

    <span class="Statement">if</span> (!output_file)
    {
        std::cerr &lt;&lt; <span class="Constant">&quot;cannot open output file&quot;</span> &lt;&lt; std::endl;
        <span class="Statement">return</span>;
    }

    <span class="Statement">do</span>
    {
        segment_size = std::min(remaining, buffer_size);
        <span class="Statement">if</span> (segment_size &lt; aead.tag_bytes())
        {
            std::cerr &lt;&lt; <span class="Constant">&quot;Invalid input file&quot;</span> &lt;&lt; std::endl;
            <span class="Statement">return</span>;
        }
        <span class="Statement">if</span> (!input_file.read(&amp;in_buffer[<span class="Constant">0</span>], segment_size))
        {
            std::cerr &lt;&lt; <span class="Constant">&quot;error reading input file&quot;</span> &lt;&lt; std::endl;
            <span class="Statement">return</span>;
        }
        <span class="Type">size_t</span> output_size = segment_size - aead.tag_bytes();
        aead.decrypt_segment(remaining == segment_size ? streaming_aead::segment_type::<span class="Type">final</span> : streaming_aead::segment_type::non_final,
            <span class="Statement">reinterpret_cast</span>&lt;<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">char</span>*&gt;(in_buffer.data()), segment_size, <span class="Constant">nullptr</span>, <span class="Constant">0</span>,
            <span class="Statement">reinterpret_cast</span>&lt;<span class="Type">unsigned</span> <span class="Type">char</span>*&gt;(&amp;out_buffer[<span class="Constant">0</span>]), output_size);
        output_file.write(out_buffer.data(), output_size);
        remaining -= segment_size;
    } <span class="Statement">while</span> (remaining);
}

</pre>
<h2 id="chdu">10. Digest utility</h2>
<p>Also included is a command-line utility 'digest.exe' which can be used to calculate message digest of any file(s) using any of the supported hash algorithms (similar to md5sum), for example, if you want to calculate
Skein-512/256 hash of a file, you can run:</p>
<pre>
   digest skein512/256 file.ext
</pre
<p>You can save the checksums to a text file using the following command:</p>
<pre>
   digest skein512/256 * > checksums.skein
</pre
<p>Like md5sum, the utility can also verify checksums saved in a file, for example, if you want to verify the hashes saved
by the previous command, you can run:</p>
<pre>
   digest -c skein512/256 checksums.skein
</pre>
<h2 id="chcryptor">11. Cryptor utility</h2>
<p>Command-line utility 'cryptor.exe' is intended to demonstrate how cppcrypto library can be utilized to encrypt or decrypt a file.
To encrypt a file, run:</p>
<pre>
   cryptor enc file.ext
</pre>
<p>To decrypt a file, run:</p>
<pre>
   cryptor dec file.ext
</pre>
<p>The utility demonstrates the steps needed for encryption. The file is encrypted using <code>streaming_aead</code> mode with Serpent algorithm with 256-bit key in CTR mode and authenticated using HMAC-Grøstl-256. The encryption key is derived from user-provided password using argon2d key derivation function.</p>
<p>The utility is provided mainly for demonstration purposes, algorithm choice is arbitrary.</p>
<h2 id="chpn">12. Portability notes</h2>
<p>At the moment we support only x86 processors (in 32-bit or 64-bit mode).
<br>To build cppcrypto from the sources you need to have yasm installed.
<br>We have successfully compiled and tested cppcrypto under the following operating systems.</p>
<h3>12.1. Windows</h3>
<p>Tested OS versions: Windows 10.
<br>Tested compilers: Visual C++ 2017, Visual C++ 2019, Visual C++ 2022.</p>
<p>First, download the latest yasm for Visual Studio and install it according to the instructions in its readme.txt.
Note that the latest stable release of yasm (1.3.0) ships vsyasm.props file which is not compatible with Visual Studio 2013 or later. The fixed version of vsyasm.props is included in the cppcrypto source archive, so you just need to replace that single file. (Alternatively, use the development version of yasm from their git repository, which reportedly fixes the compatibility issue.)</p>
<p>Then, open the supplied Visual C++ project files or solution file and build cppcrypto.
If you're using Visual Studio 2019 or later, right-click the solution and choose &quot;Retarget&quot; menu item, since the provided project files are from VS2017.</p>
<p>Experimental support for Cygwin gcc builds has been added recently; to build in cygwin, run 'make UNAME=Cygwin' and 'make UNAME=Cygwin install'.</p>
<h3>12.2. Linux</h3>
<p>Tested OS versions: Fedora 37 (x86_64).<br>
Tested compilers: gcc 12.2.1, clang 15.0.7.</p>
<p>Make sure yasm is installed, then run make and [sudo] make install as usual.</p>
<p>Note that if you do not use recent versions of libstdc++ and try to run the vectortest.sh script on Linux, you may get a crash during checking sha384 and sha512 test vectors. This is caused by a bug in libstdc++ (stack overflow on long regexes), which is fixed in latest versions. This bug does not affect the functionality of cppcrypto library anyhow, C++ regexes are only used in the test application for parsing the test vectors.</p>
<h3>12.3. Mac OS X</h3>
<p>NOTE: Mac OS X is untested as of cppcrypto-0.20.</p>
<p>Download and install yasm. Then run make and [sudo] make install to build and install cppcrypto.</p>
<h3>12.4. FreeBSD</h3>
<p>Tested OS versions: FreeBSD 13.1-RELEASE.
<br>Tested compilers: clang 13.0.0.</p>
<p>Install yasm (pkg install yasm) and GNU make (pkg install gmake). Then, run gmake and [sudo] gmake install to build and install cppcrypto.</p>
<h2 id="chdl">13. Download link</h2>
<p><a href="https://sourceforge.net/projects/cppcrypto/files">Download cppcrypto from sourceforge</a></p>
<p></p>
