<html>
<head>


<meta http-equiv="cache-control" content="max-age=0" />
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="expires" content="0" />
<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
<meta http-equiv="pragma" content="no-cache" />


<meta charset="UTF-8">
<style type="text/css">
table, th, td {
   border-width: 1px;
   border-style: solid;
   border-collapse: collapse;
   text-align:center;
   padding: 1px 5px 1px 5px;
}
th {
   background-color: lightyellow;
}
th.thh {
   background-color: lightcyan;
}
th.ths, th.thsa {
   border-top-width: 2px;
   font-style: italic;
/*   background-color: #FFF8DC; */
   font-weight: bold;
/*#FCDFFF;*/
}
th.thsa {
   border-left-width: 2px;
   border-right-width: 2px;
   background-color: lightyellow;
}
th.arch {
   border-top-width: 2px;
   font-style: italic;
   font-weight: normal;
}
th.direction {
   font-weight: normal;
}
td.best {
/*   background-color: #D8FBD8; */
}
td.algorithm {
   border-left-width: 2px;
   border-right-width: 2px;
   background-color: lightyellow;
}
.left {
   border-left-width: 2px;
}
.top {
   border-top-width: 2px;
}
.bottom {
   border-bottom-width: 2px;
}
.right {
   border-right-width: 2px;
}
td.descr {
/*   text-align: left; */
}
</style>
</head>
<body>
<h1>cppcrypto library</h1>
<h2>1. Introduction</h2>
<p>cppcrypto is a small cross-platform BSD-licensed C++ library providing some cryptographic primitives. It has no external dependencies.</p>
<p>The library thrives to be as fast as possible. CPU type is detected at runtime and the fastest implementation is selected dynamically.</p>
<p><b>Supported compilers:</b> Visual C++ 2013, Visual C++ 2015 on Windows; gcc 5.1.1 or later, clang 3.4.1 or later on Linux, OS X, FreeBSD; Solaris Studio on Solaris.
<br><b>Supported architectures:</b> x86_64 and x86.</p>
<p><a href="https://sourceforge.net/projects/cppcrypto/files">Download cppcrypto from sourceforge</a></p>
<p>Full list of supported cryptographic primitives is described below.
<h2>2. Hash algorithms</h2>
<h3>2.1. Interface description</h3>
<p>All hash algorithms derive from <code>crypto_hash</code> class and implement its interface.</p>
<pre>
    class crypto_hash
    {
    public:
        virtual void init() = 0;
        virtual void update(const uint8_t* data, size_t len) = 0;
        virtual void final(uint8_t* hash) = 0;

        virtual size_t hashsize() const = 0;
        virtual size_t blocksize() const = 0;

        // Convenience functions
        void hash_string(const uint8_t* data, size_t len, uint8_t* hash);
        void hash_string(const char* data, size_t len, uint8_t* hash);
        void hash_string(const std::string& data, uint8_t* hash);
    };
</pre>
<p>If you have a short message, you can calculate the hash using a single <code>hash_string()</code> call.
Otherwise, call <code>init()</code> to start hashing,
then call <code>update()</code> any number of times to add the next chunk of data, and finally call <code>final()</code> to get the hash.
<br>The <code>hash</code> parameter should point to a buffer large enough to accept the hash of correspondent size (length in bytes is <code>hashsize()/8</code>).</p>
<h3>2.2. Supported algorithms</h3>
<p>Classes derived from <code>crypto_hash</code>:</p>
<table>
<tr><th>Class Name</th><th>Description</th></tr>
<tr>
<td><code>blake224</code><br><code>blake256</code><br><code>blake384</code><br><code>blake512</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/BLAKE_%28hash_function%29">BLAKE</a></b> hash function (one of SHA-3 finalists) with output sizes 224/256/384/512 bits.<br>This is one of the fastest hash functions and we recommend it you are free to choose.</td>
</tr>
<tr>
<td><code>blake2b_128</code><br><code>blake2b_160</code><br><code>blake2b_224</code><br><code>blake2b_256</code><br><code>blake2b_384</code><br><code>blake2b_512</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/BLAKE_%28hash_function%29#BLAKE2">BLAKE2b</a></b> hash function with output sizes 128/160/224/256/384/512 bits.<br>This is a version of BLAKE-512 with reduced number of rounds and other simplifications.</td>
</tr>
<tr>
<td><code>blake2s_128</code><br><code>blake2s_160</code><br><code>blake2s_224</code><br><code>blake2s_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/BLAKE_%28hash_function%29#BLAKE2">BLAKE2s</a></b> hash function with output sizes 128/160/224/256 bits.<br>This is a version of BLAKE-256 with reduced number of rounds and other simplifications.</td>
</tr>
<tr>
<td><code>groestl224</code><br><code>groestl256</code><br><code>groestl384</code><br><code>groestl512</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Gr%C3%B8stl">Gr√∏stl</a></b> hash function (one of SHA-3 finalists) with output sizes 224/256/384/512 bits.</td>
</tr>
<tr>
<td><code>jh224</code><br><code>jh256</code><br><code>jh384</code><br><code>jh512</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/JH_%28hash_function%29">JH</a></b> hash function (one of SHA-3 finalists) with output sizes 224/256/384/512 bits.</td>
</tr>
<tr>
<td><code>kupyna256</code><br><code>kupyna512</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Kupyna">Kupyna</a></b> hash function (Ukrainian national standard DSTU 7564:2014) with output sizes 256/512 bits.<br>224/384-bit functions are not provided because their output is identical to the truncated 256/512-bit output.</td>
<!--<td class="descr"><b>Kupyna</b> hash function (Ukrainian national standard DSTU 7564:2014) with output sizes 256/512 bits.<br>Functions with output size 224/384 bits are not provided because their output is identical<br>to the output from 256/512 functions truncated to the corresponding number of bytes.</td>-->
</tr>
<tr>
<td><code>md5</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/MD5">MD5</a></b> hash function. Not secure and therefore not recommended; use only if you need it for compatibility.</td>
</tr>
<tr>
<td><code>sha1</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/SHA-1">SHA-1</a></b> hash function. Not secure and therefore not recommended; use only if you need it for compatibility.</td>
</tr>
<tr>
<td><code>sha224</code><br><code>sha256</code><br><code>sha384</code><br><code>sha512</code><br><code>sha512_224</code><br><code>sha512_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/SHA-2">SHA-2</a></b> hash function (NIST standard FIPS 180-4).
<br>New functions <code>sha512_224</code> and <code>sha512_256</code> are faster than <code>sha224</code> and <code>sha256</code> on 64-bit platforms.
<br>Individual functions are known as SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224 and SHA-512/256.
</td>
<!--<td class="descr"><b>SHA-2</b> hash function (NIST standard FIPS 180-4).<br>New functions <code>sha512_224</code> and <code>sha512_256</code> from the latest revision of the standard are faster than <code>sha224</code> and <code>sha256</code> on 64-bit platforms.</td>-->
</tr>
<tr>
<td><code>sha3_224</code><br><code>sha3_256</code><br><code>sha3_384</code><br><code>sha3_512</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/SHA-3">SHA-3</a></b> hash function (NIST standard FIPS 202) based on Keccak algorithm.</td>
</tr>
<tr>
<td><code>skein256_128</code><br><code>skein256_160</code><br><code>skein256_224</code><br><code>skein256_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Skein_%28hash_function%29">Skein</a></b> hash function (one of SHA-3 finalists) with block size 256 bits and output sizes 128/160/224/256 bits.<br>These functions are slower than <code>skein512</code>, so use them only if you need them for compatibility.</td>
</tr>
<tr>
<td><code>skein512_128</code><br><code>skein512_160</code><br><code>skein512_224</code><br><code>skein512_256</code><br><code>skein512_384</code><br><code>skein512_512</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Skein_%28hash_function%29">Skein</a></b> hash function (one of SHA-3 finalists) with block size 512 bits and output sizes 128/160/224/256/384/512 bits.<br>This is one of the fastest hash functions and we recommend it if you are free to choose.</td>
</tr>
<tr>
<td><code>skein1024_256</code><br><code>skein1024_384</code><br><code>skein1024_512</code><br><code>skein1024_1024</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Skein_%28hash_function%29">Skein</a></b> hash function (one of SHA-3 finalists) with block size 1024 bits and output sizes 256/384/512/1024 bits.</td>
</tr>
<tr>
<td><code>sm3</code></td>
<td class="descr"><b>SM3</b> hash function (Chinese national standard) with output size 256 bits.</td>
</tr>
<tr>
<td><code>streebog256</code><br><code>streebog512</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Streebog">Streebog</a></b> hash function (Russian standard GOST R 34.11-2012) with output sizes 256/512 bits.</td>
</tr>
<tr>
<td><code>whirlpool</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Whirlpool_%28cryptography%29">Whirlpool</a></b> hash function (recommended by NESSIE) with output size 512 bits.</td>
</tr>
</table>
<h3>2.3. Usage example</h3>
<p>The following snippet calculates BLAKE-256 hash of a string using a single function call:</p>
<pre>
    uint8_t hash[256/8];
    blake256().hash_string("The quick brown fox jumps over the lazy dog", hash);
    // Now <i>hash</i> contains the hash
</pre>
<p>The following snippet demonstrates how to calculate the hash of a very long message using the init/update/final interface:</p>
<p></p>
<pre>
    blake256 hasher;
    uint8_t hash[256/8];
    
    hasher.init();
    hasher.update(datachunk1, chunk1len);
    hasher.update(datachunk2, chunk2len);
    ...
    hasher.final(hash); // Now <i>hash</i> contains the hash
</pre>
<h3>2.4. Hashing performance</h3>
<p>Performance of various hash algorithms on three different test systems is provided in the table below (in megabytes per second).
<br>Note how 64-bit builds outperform 32-bit builds. For some algorithms 64-bit build is up to 5 times faster than 32-bit build on the same PC.
<br>It's also an interesting comparison between gcc 5.2.1 and clang 3.7.0 optimizers. Some algorithms are faster when compiled by clang, while others are faster when compiled by gcc.
</p>
<table>
<tr><th colspan="11" class="thh left top right bottom">Performance in megabytes per second (MB/s), higher number means faster<br><i>(measured by calculating a hash of a 130Kb file 100,000 times)</i></th></tr>
<tr>
<th class="left right" rowspan="2">Algorithm</th><th colspan="6" class="right">PC: Intel Xeon E5-1650 v3<br>(Haswell-EP)</th><th colspan="2" class="right">PC: Intel Core i7 930<br>(Nehalem)</th><th colspan="2" class="right">PC: Intel Core i3-3217U<br>(Ivy Bridge w/o AESNI)</th>
</tr>
<tr>
<th colspan="2" class="right">OS: Win7 x64<br>Compiler: VC++2015</th><th colspan="2" class="right">OS: openSUSE (in VM)<br>Compiler: gcc 5.2.1</th><th colspan="2" class="right">OS: openSUSE (in VM)<br>Compiler: clang 3.7.0</th><th colspan="2" class="right">OS: Win7 x64<br>Compiler: VC++2015</th><th colspan="2" class="right">OS: Win7 x64<br>Compiler: VC++2015</th>
</tr>
<tr>
</tr>
<tr><th class="thsa">128-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm">BLAKE2b/128</td><td>661</td><td class="right">543</td><td>651</td><td class="right">552</td><td>704</td><td class="right">605</td><td>490</td><td class="right">335</td><td>326</td><td class="right">262</td></tr>
<tr><td class="algorithm">BLAKE2s/128</td><td>554</td><td class="right">539</td><td>549</td><td class="right">542</td><td>554</td><td class="right">547</td><td>360</td><td class="right">205</td><td>274</td><td class="right">271</td></tr>
<tr><td class="algorithm">MD5</td><td>528</td><td class="right">509</td><td>634</td><td class="right">627</td><td>472</td><td class="right">472</td><td>382</td><td class="right">352</td><td>262</td><td class="right">252</td></tr>
<tr><td class="algorithm">Skein-256/128</td><td>383</td><td class="right">210</td><td>400</td><td class="right">186</td><td>396</td><td class="right">125</td><td>261</td><td class="right">164</td><td>175</td><td class="right">103</td></tr>
<tr><td class="algorithm">Skein-512/128</td><td>517</td><td class="right">234</td><td>570</td><td class="right">253</td><td>585</td><td class="right">118</td><td>340</td><td class="right">181</td><td>231</td><td class="right">112</td></tr>
<tr><th class="thsa">160-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm">BLAKE2b/160</td><td>661</td><td class="right">543</td><td>651</td><td class="right">552</td><td>704</td><td class="right">605</td><td>490</td><td class="right">335</td><td>326</td><td class="right">262</td></tr>
<tr><td class="algorithm">BLAKE2s/160</td><td>554</td><td class="right">539</td><td>549</td><td class="right">542</td><td>554</td><td class="right">547</td><td>360</td><td class="right">205</td><td>274</td><td class="right">271</td></tr>
<tr><td class="algorithm">Skein-256/160</td><td>383</td><td class="right">210</td><td>400</td><td class="right">186</td><td>396</td><td class="right">125</td><td>261</td><td class="right">164</td><td>175</td><td class="right">103</td></tr>
<tr><td class="algorithm">Skein-512/160</td><td>517</td><td class="right">234</td><td>570</td><td class="right">253</td><td>585</td><td class="right">118</td><td>340</td><td class="right">181</td><td>231</td><td class="right">112</td></tr>
<tr><td class="algorithm">SHA-1</td><td>789</td><td class="right">522</td><td>784</td><td class="right">512</td><td>784</td><td class="right">508</td><td>480</td><td class="right">392</td><td>361</td><td class="right">247</td></tr>
<tr><th class="thsa">224-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm">BLAKE-224</td><td>423</td><td class="best right">417</td><td>421</td><td class="right">392</td><td>427</td><td class="right">404</td><td>271</td><td class="right">151</td><td>208</td><td class="best right">204</td></tr>
<tr><td class="algorithm">BLAKE2b/224</td><td>661</td><td class="right">543</td><td>651</td><td class="right">552</td><td>704</td><td class="right">605</td><td>490</td><td class="right">335</td><td>326</td><td class="right">262</td></tr>
<tr><td class="algorithm">BLAKE2s/224</td><td>554</td><td class="right">539</td><td>549</td><td class="right">542</td><td>554</td><td class="right">547</td><td>360</td><td class="right">205</td><td>274</td><td class="right">271</td></tr>
<tr><td class="algorithm">Groestl-224</td><td>326</td><td class="right">270</td><td>279</td><td class="right">227</td><td>322</td><td class="right">229</td><td>112</td><td class="right">99</td><td>73</td><td class="right">71</td></tr>
<tr><td class="algorithm">JH-224</td><td>206</td><td class="right">146</td><td>198</td><td class="right">156</td><td>205</td><td class="right">138</td><td>132</td><td class="right">91</td><td>95</td><td class="right">71</td></tr>
<tr><td class="algorithm">SHA-224</td><td>398</td><td class="right">293</td><td>382</td><td class="right">282</td><td>382</td><td class="right">282</td><td>202</td><td class="right">162</td><td>149</td><td class="right">127</td></tr>
<tr><td class="algorithm">SHA-512/224</td><td class="best">552</td><td class="right">211</td><td>534</td><td class="right">203</td><td>532</td><td class="right">203</td><td>298</td><td class="right">155</td><td>214</td><td class="right">97</td></tr>
<tr><td class="algorithm">SHA3-224</td><td>270</td><td class="right">243</td><td>258</td><td class="right">221</td><td>260</td><td class="right">242</td><td>174</td><td class="right">143</td><td>122</td><td class="right">109</td></tr>
<tr><td class="algorithm">Skein-256/224</td><td>383</td><td class="right">210</td><td>400</td><td class="right">186</td><td>396</td><td class="right">125</td><td>261</td><td class="right">164</td><td>175</td><td class="right">103</td></tr>
<tr><td class="algorithm">Skein-512/224</td><td>517</td><td class="right">234</td><td>570</td><td class="right">253</td><td>585</td><td class="right">118</td><td class="best">340</td><td class="best right">181</td><td class="best">231</td><td class="right">112</td></tr>

<tr><th class="thsa">256-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm">BLAKE-256</td><td>423</td><td class="best right">417</td><td>421</td><td class="right">392</td><td>427</td><td class="right">404</td><td>271</td><td class="right">151</td><td>208</td><td class="best right">204</td></tr>
<tr><td class="algorithm">BLAKE2b/256</td><td>661</td><td class="right">543</td><td>651</td><td class="right">552</td><td>704</td><td class="right">605</td><td>490</td><td class="right">335</td><td>326</td><td class="right">262</td></tr>
<tr><td class="algorithm">BLAKE2s/256</td><td>554</td><td class="right">539</td><td>549</td><td class="right">542</td><td>554</td><td class="right">547</td><td>360</td><td class="right">205</td><td>274</td><td class="right">271</td></tr>
<tr><td class="algorithm">Groestl-256</td><td>326</td><td class="right">270</td><td>279</td><td class="right">227</td><td>322</td><td class="right">229</td><td>112</td><td class="right">99</td><td>73</td><td class="right">71</td></tr>
<tr><td class="algorithm">JH-256</td><td>206</td><td class="right">146</td><td>198</td><td class="right">156</td><td>205</td><td class="right">138</td><td>132</td><td class="right">91</td><td>95</td><td class="right">71</td></tr>
<tr><td class="algorithm">Kupyna-256</td><td>127</td><td class="right">54</td><td>111</td><td class="right">54</td><td>113</td><td class="right">79</td><td>77</td><td class="right">28</td><td>53</td><td class="right">25</td></tr>
<tr><td class="algorithm">SHA-256</td><td>398</td><td class="right">293</td><td>382</td><td class="right">282</td><td>382</td><td class="right">282</td><td>202</td><td class="right">162</td><td>149</td><td class="right">127</td></tr>
<tr><td class="algorithm">SHA-512/256</td><td class="best">552</td><td class="right">211</td><td>534</td><td class="right">203</td><td>532</td><td class="right">203</td><td>298</td><td class="right">155</td><td>214</td><td class="right">97</td></tr>
<tr><td class="algorithm">SHA3-256</td><td>256</td><td class="right">227</td><td>246</td><td class="right">206</td><td>245</td><td class="right">228</td><td>164</td><td class="right">133</td><td>114</td><td class="right">103</td></tr>
<tr><td class="algorithm">Skein-256/256</td><td>383</td><td class="right">210</td><td>400</td><td class="right">186</td><td>396</td><td class="right">125</td><td>261</td><td class="right">164</td><td>175</td><td class="right">103</td></tr>
<tr><td class="algorithm">Skein-512/256</td><td>517</td><td class="right">234</td><td>570</td><td class="right">253</td><td>585</td><td class="right">118</td><td class="best">340</td><td class="best right">181</td><td class="best">231</td><td class="right">112</td></tr>
<tr><td class="algorithm">Skein-1024/256</td><td>406</td><td class="right">106</td><td>481</td><td class="right">93</td><td>479</td><td class="right">108</td><td>217</td><td class="right">63</td><td>144</td><td class="right">38</td></tr>
<tr><td class="algorithm">SM3</td><td>186</td><td class="right">140</td><td>166</td><td class="right">143</td><td>170</td><td class="right">148</td><td>117</td><td class="right">101</td><td>81</td><td class="right">70</td></tr>
<tr><td class="algorithm">Streebog-256</td><td>112</td><td class="right">64</td><td>116</td><td class="right">64</td><td>113</td><td class="right">68</td><td>69</td><td class="right">42</td><td>50</td><td class="right">32</td></tr>

<tr><th class="thsa">384-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>

<tr><td class="algorithm">BLAKE-384</td><td>471</td><td class="best right">411</td><td>477</td><td class="right">421</td><td>540</td><td class="right">437</td><td class="best">340</td><td class="best right">217</td><td>227</td><td class="best right">202</td></tr>
<tr><td class="algorithm">BLAKE2b/384</td><td>661</td><td class="right">543</td><td>651</td><td class="right">552</td><td>704</td><td class="right">605</td><td>490</td><td class="right">335</td><td>326</td><td class="right">262</td></tr>
<tr><td class="algorithm">Groestl-384</td><td>246</td><td class="right">197</td><td>220</td><td class="right">181</td><td>234</td><td class="right">182</td><td>83</td><td class="right">73</td><td>54</td><td class="right">52</td></tr>
<tr><td class="algorithm">JH-384</td><td>206</td><td class="right">146</td><td>198</td><td class="right">156</td><td>205</td><td class="right">138</td><td>132</td><td class="right">91</td><td>95</td><td class="right">71</td></tr>
<tr><td class="algorithm">SHA-384</td><td class="best">552</td><td class="right">211</td><td>534</td><td class="right">203</td><td>532</td><td class="right">203</td><td>298</td><td class="right">155</td><td>214</td><td class="right">97</td></tr>
<tr><td class="algorithm">SHA3-384</td><td>194</td><td class="right">175</td><td>187</td><td class="right">152</td><td>189</td><td class="right">175</td><td>126</td><td class="right">103</td><td>89</td><td class="right">79</td></tr>
<tr><td class="algorithm">Skein-512/384</td><td>517</td><td class="right">234</td><td>570</td><td class="right">253</td><td>585</td><td class="right">118</td><td class="best">340</td><td class="right">181</td><td class="best">231</td><td class="right">112</td></tr>
<tr><td class="algorithm">Skein-1024/384</td><td>406</td><td class="right">106</td><td>481</td><td class="right">93</td><td>479</td><td class="right">108</td><td>217</td><td class="right">63</td><td>144</td><td class="right">38</td></tr>

<tr><th class="thsa">512-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm">BLAKE-512</td><td>471</td><td class="best right">411</td><td>477</td><td class="right">421</td><td>540</td><td class="right">437</td><td class="best">340</td><td class="best right">217</td><td>227</td><td class="best right">202</td></tr>
<tr><td class="algorithm">BLAKE2b/512</td><td>661</td><td class="right">543</td><td>651</td><td class="right">552</td><td>704</td><td class="right">605</td><td>490</td><td class="right">335</td><td>326</td><td class="right">262</td></tr>
<tr><td class="algorithm">Groestl-512</td><td>246</td><td class="right">197</td><td>220</td><td class="right">181</td><td>234</td><td class="right">182</td><td>83</td><td class="right">73</td><td>54</td><td class="right">52</td></tr>
<tr><td class="algorithm">JH-512</td><td>206</td><td class="right">146</td><td>198</td><td class="right">156</td><td>205</td><td class="right">138</td><td>132</td><td class="right">91</td><td>95</td><td class="right">71</td></tr>
<tr><td class="algorithm">Kupyna-512</td><td>81</td><td class="right">43</td><td>84</td><td class="right">41</td><td>88</td><td class="right">59</td><td>49</td><td class="right">22</td><td>23</td><td class="right">20</td></tr>
<tr><td class="algorithm">SHA-512</td><td class="best">552</td><td class="right">211</td><td>534</td><td class="right">203</td><td>532</td><td class="right">203</td><td>298</td><td class="right">155</td><td>214</td><td class="right">97</td></tr>
<tr><td class="algorithm">SHA3-512</td><td>136</td><td class="right">122</td><td>130</td><td class="right">103</td><td>133</td><td class="right">123</td><td>81</td><td class="right">72</td><td>61</td><td class="right">49</td></tr>
<tr><td class="algorithm">Skein-512/512</td><td>517</td><td class="right">234</td><td>570</td><td class="right">253</td><td>585</td><td class="right">118</td><td class="best">340</td><td class="right">181</td><td class="best">231</td><td class="right">112</td></tr>
<tr><td class="algorithm">Skein-1024/512</td><td>406</td><td class="right">106</td><td>481</td><td class="right">93</td><td>479</td><td class="right">108</td><td>217</td><td class="right">63</td><td>144</td><td class="right">38</td></tr>
<tr><td class="algorithm">Streebog-512</td><td>112</td><td class="right">64</td><td>116</td><td class="right">64</td><td>113</td><td class="right">68</td><td>69</td><td class="right">42</td><td>50</td><td class="right">32</td></tr>
<tr><td class="algorithm">Whirlpool</td><td>150</td><td class="right">125</td><td>147</td><td class="right">122</td><td>162</td><td class="right">122</td><td>80</td><td class="right">89</td><td>61</td><td class="right">58</td></tr>

<tr><th class="thsa">1024-bit digest</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th><th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm bottom">Skein-1024/1024</td><td class="bottom">406</td><td class="bottom right">106</td><td class="bottom">481</td><td class="right bottom">93</td><td class="bottom">479</td><td class="right bottom">108</td><td class="bottom">217</td><td class="bottom right">63</td><td class="bottom">144</td><td class="bottom right">38</td></tr>

</table>
<p>You can run the hashing performance test on your own PC using the following command:</p>
<pre>    digest test &lt;number_of_iterations&gt; &lt;filename_to_hash&gt;</pre>
<h2>3. MAC algorithms</h2>
<p>Class <code>hmac</code> is also derived from <code>crypto_hash</code> and implements the same interface. The only difference is that you need to pass a reference to a hash algorithm and a key in the constructor.
<pre>
    hmac(const crypto_hash& hash, const uint8_t* key, size_t keylen);
</pre>
<p>The key can be of any length and you can use any of the supported hash algorithms to calculate HMAC. The following sample calculates HMAC-SHA-256 of a string &quot;The quick brown fox jumps over the lazy dog&quot; with key &quot;key&quot;:</p>
<pre>
    uint8_t hmackey[3];
    hmackey[0] = 'k';
    hmackey[1] = 'e';
    hmackey[2] = 'y';
    hmac mac(sha256(), hmackey, sizeof(hmackey));
    uint8_t result[32];
    mac.hash_string("The quick brown fox jumps over the lazy dog", result);
</pre>
<h2>4. Block cipher algorithms</h2>
<h3>2.1. Interface description</h3>
<p>All block cipher algorithms derive from <code>block_cipher</code> class and implement its interface.</p>
<pre>
    class block_cipher
    {
    public:
        enum direction { encryption, decryption };

        virtual size_t blocksize() const = 0;
        virtual size_t keysize() const = 0;

        virtual bool init(const uint8_t* key, block_cipher::direction direction) = 0;
        virtual void encrypt_block(const uint8_t* in, uint8_t* out) = 0;
        virtual void decrypt_block(const uint8_t* in, uint8_t* out) = 0;
    };
</pre>
<p>A low-level interface to the block cipher. To start encryption or decryption, call <code>init()</code> (<code>key</code> should point to a key of <code>keysize()/8</code> bytes), then call <code>encrypt_block()</code> or <code>decrypt_block()</code> to encrypt or decrypt a single block of <code>blocksize()/8</code> bytes.<br>
In practice in most cases you probably want to use block ciphers in an encryption mode via <code>cbc</code> or <code>ctr</code> class described below.</p>
</html>
<h3>2.2. Supported algorithms</h3>
<p>Classes derived from <code>block_cipher</code>:</p>
<table>
<tr><th>Class Name</th><th>Description</th></tr>
<tr>
<td><code>anubis128</code><br><code>anubis160</code><br><code>anubis192</code><br><code>anubis224</code><br><code>anubis256</code><br><code>anubis288</code><br><code>anubis320</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Anubis_%28cipher%29">Anubis</a></b> cipher<br>with block size 128 bits and key sizes 128/160/192/224/256/288/320 bits.</td>
</tr>
<tr>
<td><code>aria128</code><br><code>aria192</code><br><code>aria256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/ARIA_%28cipher%29">Aria</a></b> cipher (South Korean national standard)<br>with block size 128 bits and key sizes 128/192/256 bits.</td>
</tr>
<tr>
<td><code>cast6_128</code><br><code>cast6_160</code><br><code>cast6_192</code><br><code>cast6_224</code><br><code>cast6_256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/CAST-256">CAST6</a></b> (aka <b>CAST-256</b>) cipher<br>with block size 128 bits and key sizes 128/160/192/224/256 bits.</td>
</tr>
<tr>
<td><code>camellia128</code><br><code>camellia192</code><br><code>camellia256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Camellia_%28cipher%29">Camellia</a></b> cipher (recommended by NESSIE and CRYPTREC)<br>with block size 128 bits and key sizes 128/192/256 bits.</td>
</tr>
<tr>
<td><code>kalyna128_128</code><br><code>kalyna128_256</code><br><code>kalyna256_256</code><br><code>kalyna256_512</code><br><code>kalyna512_512</code></td>
<td class="descr"><b>Kalyna</b> cipher (Ukrainian national standard DSTU 7624:2014)<br>with block sizes 128/256/512 bits and key sizes 128/256/512 bits.</td>
</tr>
<tr>
<td><code>kuznyechik</code></td>
<td class="descr"><b>Kuznyechik</b> cipher (Russian national standard GOST R 34.12-2015)<br>with block size 128 bits and key size 256 bits.</td>
</tr>
<tr>
<td><code>mars128</code><br><code>mars160</code><br><code>mars192</code><br><code>mars224</code><br><code>mars256</code><br><code>mars288</code><br><code>mars320</code><br><code>mars352</code><br><code>mars384</code><br><code>mars416</code><br><code>mars448</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/MARS_%28cryptography%29">MARS</a></b> cipher (one of AES finalists)<br>with block size 128 bits<br>and key sizes 128/160/192/224/256/288/320/352/384/416/448 bits.</td>
</tr>
<tr>
<td><code>rijndael128_128</code><br><code>rijndael128_160</code><br><code>rijndael128_192</code><br><code>rijndael128_224</code><br><code>rijndael128_256</code>
<br><code>rijndael160_128</code><br><code>rijndael160_160</code><br><code>rijndael160_192</code><br><code>rijndael160_224</code><br><code>rijndael160_256</code>
<br><code>rijndael192_128</code><br><code>rijndael192_160</code><br><code>rijndael192_192</code><br><code>rijndael192_224</code><br><code>rijndael192_256</code>
<br><code>rijndael224_128</code><br><code>rijndael224_160</code><br><code>rijndael224_192</code><br><code>rijndael224_224</code><br><code>rijndael224_256</code>
<br><code>rijndael256_128</code><br><code>rijndael256_160</code><br><code>rijndael256_192</code><br><code>rijndael256_224</code><br><code>rijndael256_256</code>
</td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">Rijndael</a></b> cipher (AES winner)<br>with block sizes 128/160/192/224/256 bits<br>and key sizes 128/160/192/224/256 bits.<br><br>Rijndael with block size 128 bits and key size 128, 192, 256 bits<br>is also known as<br> <b>AES-128, AES-192, AES-256</b>.<br><br>All 25 Rijndael variants are accelerated using AES-NI instructions,<br>if they are supported by CPU.</td>
</tr>
<tr>
<td><code>serpent128</code><br><code>serpent192</code><br><code>serpent256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Serpent_%28cipher%29">Serpent</a></b> cipher (one of AES finalists)<br>with block size 128 bits and key sizes 128/192/256 bits.</td>
</tr>
<tr>
<td><code>sm4</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/SMS4">SM4</a></b> cipher (Chinese national standard for Wireless LAN)<br>with block size 128 bits and key size 128 bits.</td>
</tr>
<tr>
<td><code>threefish256_256</code><br><code>threefish512_512</code><br><code>threefish1024_1024</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Threefish">Threefish</a></b> cipher<br>with block sizes 256/512/1024 bits and key sizes 256/512/1024 bits.</td>
</tr>
<tr>
<td><code>twofish128</code><br><code>twofish192</code><br><code>twofish256</code></td>
<td class="descr"><b><a href="https://en.wikipedia.org/wiki/Twofish">Twofish</a></b> cipher (one of AES finalists)<br>with block size 128 bits and key sizes 128/192/256 bits.</td>
</tr>
</table>
<h2>5. Encryption modes</h2>
<h3>5.1. CBC mode</h3>
<p>Class <code>cbc</code> implements the following interface:</p>
<pre>
    cbc(const block_cipher& cipher);

    void init(const uint8_t* key, size_t keylen, const uint8_t* iv, size_t ivlen, block_cipher::direction direction);

    <i>// Functions writing output to preallocated raw buffer (the fastest)</i>
    void encrypt_update(const uint8_t* in, size_t len, uint8_t* out, size_t& resultlen);
    void encrypt_final(uint8_t* out, size_t& resultlen);
    void decrypt_update(const uint8_t* in, size_t len, uint8_t* out, size_t& resultlen);
    void decrypt_final(uint8_t* out, size_t& resultlen);

    <i>// Functions writing output to std::vector (slower)</i>
    void encrypt_update(const uint8_t* in, size_t len, std::vector<uint8_t>& out);
    void encrypt_final(std::vector<uint8_t>& out);
    void decrypt_update(const uint8_t* in, size_t len, std::vector<uint8_t>& out);
    void decrypt_final(std::vector<uint8_t>& out);

    <i>// Functions writing output to std::ostream (the slowest)</i>
    void encrypt_update(const uint8_t* in, size_t len, std::ostream& out);
    void encrypt_final(std::ostream& out);
    void decrypt_update(const uint8_t* in, size_t len, std::ostream& out);
    void decrypt_final(std::ostream& out);
</pre>
<p>The functions are similar to the ones from the <code>crypto_hash</code> class.</p><p>To start encryption, pass one of the block ciphers to the constructor and initialize encryption using <code>init()</code> function. The length of the key in bytes should be equal to <code>keysize()/8</code> of the block cipher, and the length of the initialization vector (<code>iv</code>) in bytes should be equal to <code>blocksize()/8</code> of the block cipher. Then call <code>encrypt_update()</code> any number of times to add the next chunk of data of variable length. When all input is consumed by <code>encrypt_update()</code> function, call <code>encrypt_final()</code> to finish the encryption (at this stage the final block will be written to <code>out</code>).
<p>Decryption is done in a similar way.</p>
<p>If you use the low-level functions that write the output to a preallocated buffer, the <code>out</code> argument should point to the next location where the encrypted output should be written; <code>resultlen</code> is the number of bytes written to <code>out</code> as the result of the function call. Because the class implements PKCS#7 padding, the overall size of the output buffer should be equal to the size of the input rounded up to the block size of the cipher algorithm, plus one additional full block if the input size is the exact multiple of the block size. It is responsibility of the caller to make sure the buffer is large enough.</p>
<p>A simpler but slower interface accepts a reference to <code>std::vector&lt;uint8_t&gt;</code> and appends encryption or decryption result to this vector, which is dynamically resized as needed, so that you do not need to calculate and allocate a buffer of proper size in advance:</p>
<p>An even simpler but slower interface writes the output to <code>std::ostream</code>:</p>
<p>Note that regardless of which interface you use, you still need to call <code>init()</code> function to set up the key and initialization vector.</p>
<h3>5.2. CTR mode</h3>
<p>Class <code>ctr</code> implements the following interface:</p>
<pre>
    ctr(const block_cipher& cipher);

    void init(const uint8_t* key, size_t keylen, const uint8_t* iv, size_t ivlen, block_cipher::direction direction);
    void encrypt(const uint8_t* in, size_t len, uint8_t* out);
    void decrypt(const uint8_t* in, size_t len, uint8_t* out);
</pre>
<p>CTR mode turns block cipher into a stream cipher, so no padding is needed in this mode and the size of the output buffer must be the same as the size of the input data.
The length of the key in bytes should be equal to <code>keysize()/8</code> of the block cipher, and the length of the initialization vector (<code>iv</code>) in bytes should be equal to or smaller than <code>blocksize()/8</code> of the block cipher.
Since all output is produced immediately, no finalization function is needed in this mode.</p>
<h3>5.3. Encryption performance</h3>
<table>
<tr><th colspan="7" class="thh left top right">
Performance in megabytes per second (MB/s), higher number means faster<br><i>(measured by encrypting a 130Kb file in CBC mode 100,000 times)</i>
</th></tr>
<tr>
<th rowspan="3" class="left right top bottom">Algorithm</th><th colspan="6" class="left right top">PC: Intel Xeon E5-1650 v3</th>
</tr>
<tr>
<th colspan="2" class="left right">OS: Win7 x64<br>Compiler: VC++2015</th>
<th colspan="2" class="left right">OS: openSUSE (in VM)<br>Compiler: gcc 5.2.1</th>
<th colspan="2" class="left right">OS: openSUSE (in VM)<br>Compiler: clang 3.7.0</th>
</tr>
<tr>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
<th class="arch">64-bit build</th><th class="arch right">32-bit build</th>
</tr>
<tr><td class="algorithm">Anubis-128</td><td class="top">225</td><td class="right top">138</td><td class="top">208</td><td class="right top">178</td><td class="top">198</td><td class="right top">169</td>
<tr><td class="algorithm">Anubis-160</td><td>206</td><td class="right">128</td><td>195</td><td class="right">167</td><td>186</td><td class="right">156</td>
<tr><td class="algorithm">Anubis-192</td><td>198</td><td class="right">119</td><td>196</td><td class="right">157</td><td>172</td><td class="right">145</td>
<tr><td class="algorithm">Anubis-224</td><td>186</td><td class="right">112</td><td>186</td><td class="right">147</td><td>162</td><td class="right">137</td>
<tr><td class="algorithm">Anubis-256</td><td>176</td><td class="right">105</td><td>175</td><td class="right">138</td><td>152</td><td class="right">128</td>
<tr><td class="algorithm">Anubis-288</td><td>163</td><td class="right">100</td><td>166</td><td class="right">130</td><td>146</td><td class="right">121</td>
<tr><td class="algorithm">Anubis-320</td><td>157</td><td class="right">94</td><td>158</td><td class="right">124</td><td>136</td><td class="right">115</td>
<tr><td class="algorithm top">Aria-128</td><td class="top">135</td><td class="right top">113</td><td class="top">155</td><td class="right top">154</td><td class="top">150</td><td class="right top">153</td>
<tr><td class="algorithm">Aria-192</td><td>116</td><td class="right">98</td><td>134</td><td class="right">133</td><td>129</td><td class="right">133</td>
<tr><td class="algorithm">Aria-256</td><td>102</td><td class="right">86</td><td>119</td><td class="right">118</td><td>114</td><td class="right">117</td>
<tr><td class="algorithm top">Camellia-128</td><td class="top">148</td><td class="right top">94</td><td class="top">153</td><td class="right top">130</td><td class="top">143</td><td class="right top">149</td>
<tr><td class="algorithm">Camellia-192</td><td>113</td><td class="right">71</td><td>118</td><td class="right">99</td><td>108</td><td class="right">114</td>
<tr><td class="algorithm">Camellia-256</td><td>113</td><td class="right">71</td><td>117</td><td class="right">99</td><td>108</td><td class="right">114</td>
<tr><td class="algorithm top">CAST6-128</td><td class="top">109</td><td class="right top">99</td><td class="top">104</td><td class="right top">101</td><td class="top">102</td><td class="right top">94</td>
<tr><td class="algorithm">CAST6-160</td><td>109</td><td class="right">99</td><td>104</td><td class="right">101</td><td>102</td><td class="right">94</td>
<tr><td class="algorithm">CAST6-192</td><td>109</td><td class="right">99</td><td>104</td><td class="right">101</td><td>102</td><td class="right">94</td>
<tr><td class="algorithm">CAST6-224</td><td>109</td><td class="right">99</td><td>104</td><td class="right">101</td><td>102</td><td class="right">94</td>
<tr><td class="algorithm bottom">CAST6-256</td><td class="bottom">109</td><td class="right bottom">99</td><td>104</td><td class="right">101</td><td>102</td><td class="right">94</td>
<tr><td class="algorithm top">Kalyna-128/128</td><td class="top">179</td><td class="right top">112</td><td class="top">236</td><td class="right top">130</td><td class="top">206</td><td class="right top">186</td>
<tr><td class="algorithm">Kalyna-128/256</td><td>132</td><td class="right">82</td><td>175</td><td class="right">95</td><td>148</td><td class="right">137</td>
<tr><td class="algorithm">Kalyna-256/256</td><td>177</td><td class="right">85</td><td>206</td><td class="right">88</td><td>167</td><td class="right">113</td>
<tr><td class="algorithm">Kalyna-256/512</td><td>140</td><td class="right">67</td><td>135</td><td class="right">69</td><td>131</td><td class="right">89</td>
<tr><td class="algorithm">Kalyna-512/512</td><td>155</td><td class="right">66</td><td>124</td><td class="right">71</td><td>119</td><td class="right">83</td>
<tr><td class="algorithm top">Kuznyechik</td><td class="top">109</td><td class="right top">60</td><td class="top">113</td><td class="right top">68</td><td class="top">112</td><td class="right top">70</td>
<tr><td class="algorithm top">Mars-128</td><td class="top">159</td><td class="right top">136</td><td class="top">154</td><td class="right top">154</td><td class="top">138</td><td class="right top">140</td>
<tr><td class="algorithm">Mars-160</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-192</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-224</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-256</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-288</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-320</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-352</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-384</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-416</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm">Mars-448</td><td>159</td><td class="right">136</td><td>154</td><td class="right">154</td><td>138</td><td class="right">140</td>
<tr><td class="algorithm top">Rijndael-128/128</td><td class="top">657</td><td class="right top">656</td><td class="top">633</td><td class="right top">632</td><td class="top">633</td><td class="right top">629</td>
<tr><td class="algorithm">Rijndael-128/160</td><td>607</td><td class="right">607</td><td>589</td><td class="right">578</td><td>588</td><td class="right">579</td>
<tr><td class="algorithm">Rijndael-128/192</td><td>564</td><td class="right">566</td><td>541</td><td class="right">544</td><td>545</td><td class="right">537</td>
<tr><td class="algorithm">Rijndael-128/224</td><td>525</td><td class="right">527</td><td>505</td><td class="right">506</td><td>505</td><td class="right">502</td>
<tr><td class="algorithm">Rijndael-128/256</td><td>493</td><td class="right">490</td><td>472</td><td class="right">474</td><td>476</td><td class="right">471</td>
<tr><td class="algorithm top">Rijndael-160/128</td><td class="top">339</td><td class="right top">253</td><td class="top">315</td><td class="right top">290</td><td class="top">331</td><td class="right top">322</td>
<tr><td class="algorithm">Rijndael-160/160</td><td>339</td><td class="right">254</td><td>315</td><td class="right">290</td><td>331</td><td class="right">322</td>
<tr><td class="algorithm">Rijndael-160/192</td><td>318</td><td class="right">238</td><td>293</td><td class="right">272</td><td>310</td><td class="right">302</td>
<tr><td class="algorithm">Rijndael-160/224</td><td>299</td><td class="right">223</td><td>276</td><td class="right">258</td><td>292</td><td class="right">286</td>
<tr><td class="algorithm">Rijndael-160/256</td><td>282</td><td class="right">211</td><td>263</td><td class="right">245</td><td>275</td><td class="right">267</td>
<tr><td class="algorithm top">Rijndael-192/128</td><td class="top">425</td><td class="right top">373</td><td class="top">361</td><td class="right top">327</td><td class="top">459</td><td class="right top">452</td>
<tr><td class="algorithm">Rijndael-192/160</td><td>425</td><td class="right">373</td><td>355</td><td class="right">330</td><td>456</td><td class="right">457</td>
<tr><td class="algorithm">Rijndael-192/192</td><td>425</td><td class="right">373</td><td>357</td><td class="right">327</td><td>457</td><td class="right">456</td>
<tr><td class="algorithm">Rijndael-192/224</td><td>399</td><td class="right">352</td><td>333</td><td class="right">309</td><td>429</td><td class="right">426</td>
<tr><td class="algorithm">Rijndael-192/256</td><td>378</td><td class="right">334</td><td>320</td><td class="right">295</td><td>402</td><td class="right">398</td>
<tr><td class="algorithm top">Rijndael-224/128</td><td class="top">370</td><td class="right top">287</td><td class="top">332</td><td class="right top">306</td><td class="top">355</td><td class="right top">346</td>
<tr><td class="algorithm">Rijndael-224/160</td><td>370</td><td class="right">287</td><td>332</td><td class="right">306</td><td>355</td><td class="right">346</td>
<tr><td class="algorithm">Rijndael-224/192</td><td>370</td><td class="right">287</td><td>332</td><td class="right">306</td><td>355</td><td class="right">346</td>
<tr><td class="algorithm">Rijndael-224/224</td><td>370</td><td class="right">287</td><td>334</td><td class="right">306</td><td>355</td><td class="right">346</td>
<tr><td class="algorithm">Rijndael-224/256</td><td>349</td><td class="right">268</td><td>314</td><td class="right">290</td><td>334</td><td class="right">329</td>
<tr><td class="algorithm top">Rijndael-256/128</td><td class="top">528</td><td class="right top">527</td><td class="top">501</td><td class="right top">501</td><td class="top">501</td><td class="right top">499</td>
<tr><td class="algorithm">Rijndael-256/160</td><td>528</td><td class="right">527</td><td>501</td><td class="right">501</td><td>501</td><td class="right">499</td>
<tr><td class="algorithm">Rijndael-256/192</td><td>528</td><td class="right">527</td><td>501</td><td class="right">501</td><td>501</td><td class="right">499</td>
<tr><td class="algorithm">Rijndael-256/224</td><td>528</td><td class="right">527</td><td>501</td><td class="right">501</td><td>501</td><td class="right">499</td>
<tr><td class="algorithm">Rijndael-256/256</td><td>528</td><td class="right">527</td><td>501</td><td class="right">501</td><td>501</td><td class="right">499</td>
<tr><td class="algorithm top">Serpent-128</td><td class="top">84</td><td class="right top">96</td><td class="top">89</td><td class="right top">93</td><td class="top">90</td><td class="right top">93</td>
<tr><td class="algorithm">Serpent-192</td><td>84</td><td class="right">96</td><td>89</td><td class="right">93</td><td>90</td><td class="right">93</td>
<tr><td class="algorithm bottom">Serpent-256</td><td class="bottom">84</td><td class="right bottom">96</td><td>89</td><td class="right">93</td><td>90</td><td class="right">93</td>
<tr><td class="algorithm top">SM4</td><td class="top">77</td><td class="right top">75</td><td class="top">91</td><td class="right top">95</td><td class="top">75</td><td class="right top">80</td>
<tr><td class="algorithm top">Threefish-256/256</td><td class="top">334</td><td class="right top">115</td><td class="top">408</td><td class="right top">111</td><td class="top">396</td><td class="right top">137</td>
<tr><td class="algorithm">Threefish-512/512</td><td>343</td><td class="right">118</td><td>620</td><td class="right">108</td><td>610</td><td class="right">129</td>
<tr><td class="algorithm">Threefish-1024/1024</td><td>324</td><td class="right">104</td><td>359</td><td class="right">83</td><td>361</td><td class="right">100</td>
<tr><td class="algorithm top">Twofish-128</td><td class="top">171</td><td class="right top">151</td><td class="top">171</td><td class="right top">164</td><td class="top">162</td><td class="right top">167</td>
<tr><td class="algorithm">Twofish-192</td><td>171</td><td class="right">151</td><td>171</td><td class="right">164</td><td>162</td><td class="right">167</td>
<tr><td class="algorithm bottom">Twofish-256</td><td class="bottom">171</td><td class="right bottom">151</td><td class="bottom">171</td><td class="right bottom">164</td><td class="bottom">162</td><td class="right bottom">167</td>
</table>
<p>You can run the encryption performance test on your own PC using the following command:</p>
<pre>    digest bctest &lt;number_of_iterations&gt; &lt;filename_to_encrypt&gt;</pre>
<h2>6. Key derivation functions</h2>
<h3>6.1. PBKDF2</h3>
<p>Function <a href="https://en.wikipedia.org/wiki/PBKDF2">pbkdf2</a> has the following prototype:</p>
<pre>
    void pbkdf2(hmac& hmac, const uint8_t* salt, size_t salt_len, int iterations, uint8_t* dk, size_t dklen);
</pre>
<p>You can use this function to derive an encryption key from a password. The password should be passed to the constructor of <code>hmac</code> object as the key.</p>
<p>The following snippet generates a 256-bit key from password "password" and salt "salt" using PBKDF2 algorithm with 100000 iterations of HMAC-SHA256:</p>
<pre>
    hmac hmac(sha256(), "password");
    uint8_t key[256 / 8];
    pbkdf2(hmac, (const uint8_t*)"salt", 4, 100000, key, sizeof(key));
</pre>
<h3>6.2. scrypt</h3>
<p>Function <a href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a> has the following prototype:</p>
<pre>
<i>    /*
    scrypt key derivation function.

    Input:
    hmac    HMAC to use (e.g. HMAC-SHA-256). The password shall be passed to the constructor of hmac object.
    salt    Salt.
    N       CPU/Memory cost parameter, must be larger than 1, a power of 2 and less than 2<sup>16*r</sup>.
    r       Block size factor parameter.
    p       Parallelization parameter, a positive integer less than 2<sup>30</sup>/r.
    dklen   Intended output length of the derived key; a positive integer less than or equal to (2<sup>32</sup> - 1) * 32.

    Output:
    dk      Derived key, of length dklen bytes.
    */</i>
    void scrypt(hmac& hmac, const uint8_t* salt, size_t salt_len, size_t N, size_t r, size_t p, uint8_t* dk, size_t dklen);
</pre>
<p>You can use this function to derive an encryption key from a password. The password should be passed to the constructor of <code>hmac</code> object as the key.</p>
<p>The following snippet generates a 256-bit key from password "password" and salt "salt" using scrypt with N=16384, r=8 and p=16 (which takes 0.10 seconds on Intel Xeon E5-1650 v3):</p>
<pre>
    hmac hmac(sha256(), "password");
    uint8_t key[256 / 8];
    scrypt(hmac, (const uint8_t*)"salt", 4, 16384, 8, 16, key, sizeof(key));
</pre>
<h3>6.3. Argon2</h3>
<p>Argon2 is a winner of Password Hashing Competition and is the recommended function for hashing passwords.</p>
<p>There are two versions of Argon2 function: <code>argon2i</code> and <code>argon2d</code>. Argon2i is the safest against side-channel attacks, while Argon2d provides the highest resistance against GPU cracking attacks.</p>
<pre><i>    /*
    Argon2 key derivation function.

    Input:
    password Passphrase.
    salt     Salt.
    t        A time cost, which defines the amount of computation realized and therefore the execution time, given in number of iterations.
    m        A memory cost, which defines the memory usage, given in kibibytes.
    p        A parallelism degree, which defines the number of parallel threads.
    dklen    Intended output length of the derived key, given in bytes.

    Output:
    dk       Derived key, of length dklen bytes.
    */</i>
    void argon2d(const char* password, uint32_t pwd_len, const uint8_t* salt, uint32_t salt_len, uint32_t p, uint32_t m, uint32_t t, uint8_t* dk, uint32_t dklen);
    void argon2i(const char* password, uint32_t pwd_len, const uint8_t* salt, uint32_t salt_len, uint32_t p, uint32_t m, uint32_t t, uint8_t* dk, uint32_t dklen);
</pre>
<p>The following snippet generates a 256-bit key from password "password" and salt "salt" using <code>argon2i</code> function with p=4, m=4096 and t=1000 (which takes 0.68 seconds on Intel Xeon E5-1650 v3):</p>
<pre>
    uint8_t key[256 / 8];
    argon2i("password", 8, (const uint8_t*)"salt", 4, 4, 4096, 1000, key, sizeof(key));
</pre>
<p>Our implementation of Argon2 is faster than the optimized reference implementation, which needs 1.05 seconds to compute the same Argon2i hash on the same PC (both implementations were compiled by VC++ 2015 with /O2 optimization).</p>
<h2>7. Digest utility</h2>
<p>Also included is a command-line utility 'digest.exe' which can be used to calculate message digest of any file(s) using any of the supported hash algorithms (similar to md5sum), for example, if you want to calculate
Skein-512/256 hash of a file, you can run:</p>
<pre>
   digest skein512/256 file.ext
</pre
<p>You can save the checksums to a text file using the following command:</p>
<pre>
   digest skein512/256 * > checksums.skein
</pre
<p>Like md5sum, the utility can also verify checksums saved in a file, for example, if you want to verify the hashes saved
by the previous command, you can run:</p>
<pre>
   digest -c skein512/256 checksums.skein
</pre>
<h2>8. Platform notes</h2>
<p>At the moment we support only x86 processors (in 32-bit or 64-bit mode).
<br>To build cppcrypto from the sources you need to have yasm installed.
<br>We have successfully compiled and tested cppcrypto under the following operating systems.</p>
<h3>8.1. Windows</h3>
<p>Tested OS versions: Windows 7, Windows 10.
<br>Tested compilers: Visual C++ 2013, Visual C++ 2015.</p>
<p>First, download the latest yasm for Visual Studio and install it according to the instructions in its readme.txt.
Note that the latest stable release of yasm (1.3.0) ships vsyasm.props file which is not compatible with Visual Studio 2013 and 2015. The fixed version of vsyasm.props is included in the cppcrypto source archive, so you just need to replace that single file. (Alternatively, use the development version of yasm from their git repository, which reportedly fixes the compatibility issue.)</p>
<p>Then, open the supplied Visual C++ project files or solution file and build cppcrypto.
If you're using Visual Studio 2015, right-click each project and choose &quot;Upgrade VC Compilers and Libraries&quot; menu item, since the provided project files are from VS2013.</p>
<p>If you use the precompiled static libraries then you don't need yasm.
Just link against cppcryptomd.lib or cppcryptomt.lib depending on your /MT or /MD settings.
</p>
<h3>8.2. Linux</h3>
<p>Tested OS versions: openSUSE Tumbleweed (x86_64 and i586), Debian Sid (x86_64), Fedora 23 (x86_64).<br>
Tested compilers: gcc 5.1.1, gcc 5.2.1, clang 3.7.0.</p>
<p>Make sure yasm is installed, then run make and [sudo] make install as usual.</p>
<p>Note that if you try to run the vectortest.sh script on Linux, you may get a crash during checking sha384 and sha512 test vectors. This is caused by a bug in the current version of libstdc++ (stack overflow on long regexes). The developers of libstdc++ are informed and acknowledge the bug. This bug does not affect the functionality of cppcrypto library anyhow, C++ regexes are only used in the test application for parsing the test vectors.</p>
<h3>8.3. Mac OS X</h3>
<p>Tested OS versions: OS X 10.11.1 El Capitan.
<br>Tested compilers: Apple LLVM version 7.0.0 (clang-700.1.76).</p>
<p>Download and install yasm. Then run make and [sudo] make install to build and install cppcrypto.</p>
<h3>8.4. FreeBSD</h3>
<p>Tested OS versions: FreeBSD 10.2-RELEASE.
<br>Tested compilers: clang 3.4.1.</p>
<p>Install yasm (pkg install yasm) and GNU make (pkg install gmake). Then, run gmake and [sudo] gmake install to build and install cppcrypto.</p>
<h3>8.5. Solaris</h3>
<p>Tested OS versions: Solaris 11.3.
<br>Tested compilers: Solaris Studio 12.4.</p>
<p>Install yasm from OpenCSW. Be sure yasm, gmake, ginstall and Solaris Studio compiler (CC) are in the PATH. Then, run gmake and [sudo] gmake install to build and install cppcrypto.</p>
<h2>9. Download link</h2>
<p><a href="https://sourceforge.net/projects/cppcrypto/files">Download cppcrypto from sourceforge</a></p>
<p></p>
